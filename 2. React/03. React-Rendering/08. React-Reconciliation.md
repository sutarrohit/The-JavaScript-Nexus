# React’s reconciliation algorithm

## What is reconciliation?

Reconciliation is React’s process of comparing the new virtual DOM tree with the previous one to figure out the **minimal** set of changes to apply to the real DOM. React does this because direct DOM operations are expensive — the goal is to update only what changed.

React keeps two trees:

-   **Old virtual DOM** (previous render)
-   **New virtual DOM** (current render)

It walks both trees and determines differences — then issues DOM mutations to reflect those diffs.

---

## High-level rules React uses

1. **Same type → update props**
   If two nodes have the same type (e.g. `<div>` vs `<div>`, or `<MyComp>` vs `<MyComp>`), React updates the existing DOM node / component instance and updates props.

2. **Different type → replace**
   If types differ (e.g. `<div>` vs `<span>`, or `<A>` vs `<B>`), React unmounts the old node and mounts the new one.

3. **Keys for lists**
   When children are in arrays, React uses `key` to match old children with new children. Keys are crucial to avoid unnecessary re-creates and to preserve stateful child identity (e.g. input values, component state).

4. **Minimal DOM changes**
   React attempts to only apply the minimal set of operations: update attributes, reorder nodes, insert or remove nodes.

React’s modern implementation uses the **Fiber** architecture to break work into units, support prioritization, and enable incremental rendering — but the core diff rules above still govern identity matching.

---

## How keys work (and why they matter)

When rendering lists:

```jsx
{
    items.map((item) => <ListItem key={item.id} data={item} />);
}
```

React uses `key` to:

-   Find which item corresponds to which previous item.
-   Reuse the existing DOM node / component instance when the same `key` is present.
-   If a key is missing or reused incorrectly, React may reorder/unmount/mount and you’ll lose local state.

### Bad keys

-   **Using index as key**: `key={index}` — bad when list order can change or items are inserted/removed. It causes React to think old item at index X is the same after a splice, producing wrong DOM reuse and bugs (e.g. input caret jump, wrong local state).
-   **Using uuid() generated on each render**: `key={uuid()}` — also bad because it changes every render; React will always unmount & remount every item.

### Good keys

-   Use a stable, unique identifier tied to the item (database id, slug, etc.).
-   Only when items truly have no identity and list is static, index can be acceptable.

---

## Example: why index key breaks things

Imagine items `A, B, C` with inputs inside each item. If you remove `B`:

-   With stable keys: A and C keep their input values and state.
-   With index keys: item at index 1 becomes `C`, React reuses the DOM for `C` but it was previously `B` — input values/state swap unexpectedly.

---

## Reconciliation for components vs DOM nodes

-   **DOM nodes**: React updates attributes, event listeners, and text nodes.
-   **Functional/Class components**: React may re-run the function (or class `render`) and may call lifecycle hooks. If type is same, the component instance is preserved and receives updated props; otherwise it's unmounted and a new one mounted.

---

## Performance optimizations (practical)

-   **Use stable keys for lists** (most important).
-   **Avoid anonymous functions/objects inline for props** that cause shallow comparisons to fail (if using `React.memo` or `PureComponent`), e.g. `onClick={() => doSomething(item)}` vs `useCallback`.
-   **`React.memo`**: wrap functional components to skip re-render when props shallowly equal.

    ```jsx
    const Item = React.memo(({ data }) => {
        /* ... */
    });
    ```

-   **`useCallback` / `useMemo`**: memoize handlers and expensive computations to avoid prop identity churn.
-   **`shouldComponentUpdate` / `PureComponent`**: for class components, customize update behavior.
-   **Keyed fragments**: you can add `key` to fragments `<React.Fragment key={...}>` when rendering lists of fragments.

---

## Example: good list rendering

```jsx
function TodoList({ todos, onToggle }) {
    return (
        <ul>
            {todos.map((todo) => (
                <li key={todo.id}>
                    <label>
                        <input type='checkbox' checked={todo.done} onChange={() => onToggle(todo.id)} />
                        {todo.text}
                    </label>
                </li>
            ))}
        </ul>
    );
}
```

-   `todo.id` is stable → correct reconciliation.
-   `onChange` inline is okay if you don’t memoize child or create perf issues; otherwise use `useCallback`.

---

## Debugging reconciliation issues

-   If child state seems to jump or inputs lose caret/selection when list updates → **first suspect keys**.
-   Use React DevTools to inspect component tree and props; watch for unexpected unmount/mount cycles.
-   Add `console.log` to `useEffect(() => () => console.log('unmount'))` or `componentWillUnmount` to see unmounts.

---

## Common misconceptions

-   **“React re-renders everything”** — React will call render functions often, but DOM updates only happen if the virtual DOM diff says something changed. Frequent render calls without expensive DOM updates are typically cheap.
-   **“Keys help performance always”** — keys help reconciliation correctness and can improve performance by preserving instances; but trivial key choice (like index for dynamic lists) breaks correctness.

---

## Quick checklist for safe reconciliation

-   Give lists stable, unique `key`s (IDs).
-   Don’t use `index` as `key` if list changes.
-   Avoid generating new key values per render (no `uuid()` in render).
-   Use `React.memo`, `useCallback`, and `useMemo` selectively (measure if needed).
-   Verify with DevTools for unexpected mounts/unmounts.

---

If you want, I can:

-   show a minimal demo that demonstrates the index-key bug (with code and expected behavior),
-   or give a checklist for converting a component to use `React.memo` safely,
-   or review a snippet of your code and point out reconciliation issues.

Which would you like next?
