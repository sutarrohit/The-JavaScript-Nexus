# **Chapter 1 – Asynchrony: Now & Later**

## **1. The Core Concept**

-   Programming in JavaScript often involves **two distinct time frames**:

    -   **Now** → the part of the program that runs immediately when the code executes.
    -   **Later** → the part that runs after some delay or in response to an event.

-   Asynchrony is **not** about speed — it’s about **managing time gaps** between these two phases.

**Example – Now vs Later:**

```js
var answer = now();
setTimeout(later, 1000); // schedules for later

function now() {
    return 21;
}
function later() {
    console.log("Meaning of life:", answer * 2);
}
```

-   Now: `now()` executes immediately, `setTimeout` schedules `later`.
-   Later: `later()` executes after \~1 second.

---

## **2. Why Asynchrony Exists**

-   JavaScript is **single-threaded** — only one piece of code runs at any given time.
-   Certain operations (network requests, timers, user events) can’t finish instantly.
-   Instead of blocking, JS schedules the remaining work for later — letting the program continue.

---

## **3. Callbacks – The Traditional Tool**

-   Most asynchronous JS has historically been managed with **callbacks**.
-   Example with Ajax:

```js
ajax("http://some.url", function (data) {
    console.log(data);
});
```

-   Ajax returns immediately; callback runs _later_ when the network responds.

⚠ **Synchronous Ajax exists** but should never be used because it freezes the UI.

---

## **4. Async Console Behavior**

-   `console.log()` can be **asynchronous** in some environments due to slow I/O.
-   In rare cases, an object logged may appear with updated values instead of the state at log time.
-   Example:

```js
var a = { index: 1 };
console.log(a);
a.index++;
// Some browsers may show `{ index: 2 }` instead of `{ index: 1 }`
```

-   To avoid, **snapshot**:

```js
console.log(JSON.stringify(a));
```

---

## **5. The Event Loop**

-   The **event loop** is the mechanism that:

    -   Keeps track of pending tasks (events).
    -   Executes one task at a time (each iteration = a “tick”).

-   The JS engine does not manage time; the **host environment** (browser, Node.js) schedules events.

**Pseudo-code:**

```js
var eventLoop = [];
while (true) {
    if (eventLoop.length > 0) {
        var event = eventLoop.shift();
        try {
            event();
        } catch (err) {
            reportError(err);
        }
    }
}
```

**Key facts:**

-   `setTimeout(fn, delay)` → sets a timer; when done, host puts `fn` into event queue.
-   If queue is busy, execution may be **later than expected**.

---

## **6. Async vs Parallel**

-   **Async**: separation of now & later (time gap).
-   **Parallel**: simultaneous execution (multi-threading).
-   JS is **not parallel** for normal code; it’s **run-to-completion**:

    -   Once a function starts, nothing else runs until it finishes.

---

## **7. Concurrency**

-   Multiple asynchronous “processes” can be active in the same program.
-   These processes **interleave** events in the event loop.

**Non-interacting concurrency:**

-   Independent processes, order doesn’t matter.

```js
ajax(url1, foo);
ajax(url2, bar);
```

**Interacting concurrency:**

-   Shared state → can cause **race conditions**.

```js
var res = [];
ajax(url1, function (data) {
    res[0] = data;
});
ajax(url2, function (data) {
    res[1] = data;
});
```

-   Without coordination, results may arrive in unexpected order.

---

## **8. Coordination Patterns**

### **8.1 Gates**

-   Wait for multiple async results before proceeding.

```js
var a, b;
function foo(x) {
    a = x * 2;
    if (a && b) baz();
}
function bar(y) {
    b = y * 2;
    if (a && b) baz();
}
```

### **8.2 Latches**

-   “First one wins”; ignore later results.

```js
var a;
function foo(x) {
    if (!a) {
        a = x * 2;
        baz();
    }
}
function bar(x) {
    if (!a) {
        a = x / 2;
        baz();
    }
}
```

---

## **9. Cooperative Concurrency**

-   Breaking long tasks into small chunks so others can run in between.
-   Prevents UI freezing.

```js
function response(data) {
    var chunk = data.splice(0, 1000);
    process(chunk);
    if (data.length > 0) {
        setTimeout(function () {
            response(data);
        }, 0);
    }
}
```

-   `setTimeout(..., 0)` → lets other events run before continuing.

---

## **10. Job Queue (Microtasks)**

-   ES6 introduced the **Job Queue** for microtasks (e.g., Promises).
-   Jobs run **after current code finishes** but **before** next event loop tick.
-   Allows higher-priority scheduling than normal callbacks.

**Conceptual example:**

```js
console.log("A");
setTimeout(() => console.log("B"), 0);
Promise.resolve().then(() => console.log("C"));
```

**Output:**
`A`
`C` (Job Queue before next tick)
`B` (next event loop tick)

---

## **11. Statement Ordering**

-   JS engines can reorder statements internally for optimization as long as results remain the same.
-   If reordering is observable, it’s either:

    -   A bug in your code (likely a race condition).
    -   A bug in the JS engine (rare).

---

## **Key Lessons from Chapter 1**

1. **Asynchrony is fundamental** in JS — everything from user events to Ajax responses depends on it.
2. The **event loop** schedules work, ensuring single-threaded execution.
3. **Race conditions** occur when async tasks share state without proper coordination.
4. **Gates, latches, batching** help control async flow.
5. **Job Queue** is crucial for microtask scheduling, especially with Promises.
6. Writing async code requires **mindfulness of ordering** and **interleaving**.
