# **Chapter 4 – Generators**

## **1. Breaking Run-to-Completion**

-   Normally, JavaScript functions have **run-to-completion semantics**:

    -   Once a function starts, it runs until it ends (no pauses).

-   **Generators break this rule**:

    -   With `yield`, execution can pause mid-function.
    -   Control returns to the caller, and later resumes where it left off.

-   This introduces a **two-way message passing system** between caller and generator.

---

## **2. Generator’ing Values**

-   A generator is declared with `function*`.
-   Each `yield` pauses execution and outputs a value.
-   The `.next()` method:

    -   Resumes execution.
    -   Returns an object `{ value, done }`.

**Example:**

```js
function* numbers() {
    yield 1;
    yield 2;
    yield 3;
}
let it = numbers();
console.log(it.next()); // { value: 1, done: false }
console.log(it.next()); // { value: 2, done: false }
console.log(it.next()); // { value: 3, done: false }
console.log(it.next()); // { value: undefined, done: true }
```

---

## **3. Iterating Generators Asynchronously**

-   Generators integrate naturally with **Promises**.
-   By yielding a Promise, you pause until it resolves.
-   A **runner function** drives the generator, calling `.next()` after each async resolution.

**Example Runner:**

```js
function run(gen) {
    var it = gen();
    function step(lastValue) {
        let { value, done } = it.next(lastValue);
        if (!done) {
            Promise.resolve(value).then(step);
        }
    }
    step();
}
```

**Usage:**

```js
run(function* () {
    var data = yield fetch("/api");
    var json = yield data.json();
    console.log(json);
});
```

-   Looks synchronous, but runs asynchronously.

---

## **4. Generators + Promises**

-   Generators simplify promise chaining.
-   Instead of:

```js
fetch("/data")
    .then((res) => res.json())
    .then(console.log);
```

-   You can write:

```js
function* main() {
    var res = yield fetch("/data");
    var json = yield res.json();
    console.log(json);
}
run(main);
```

-   Makes async code **linear and readable**.

---

## **5. Generator Delegation**

-   `yield*` delegates control to another generator.
-   This allows composition of generators.

**Example:**

```js
function* inner() {
    yield "A";
    yield "B";
}
function* outer() {
    yield "Start";
    yield* inner();
    yield "End";
}
[...outer()]; // ["Start", "A", "B", "End"]
```

---

## **6. Generator Concurrency**

-   Multiple generators can be interleaved to represent **concurrent tasks**.
-   Each generator yields when waiting, allowing others to proceed.
-   Useful in cooperative multitasking.

**Example (conceptual):**

```js
function* task1() {
    yield "task1 step1";
    yield "task1 step2";
}
function* task2() {
    yield "task2 step1";
    yield "task2 step2";
}
```

-   A scheduler can alternate between tasks, simulating concurrency.

---

## **7. Thunks**

-   A **thunk** is a function that wraps a value or computation for later execution.
-   Before Promises, thunks were used with Generators for async control.
-   Example thunk:

```js
function readFileThunk(filename) {
    return function (callback) {
        fs.readFile(filename, callback);
    };
}
```

-   Yielding thunks allowed async control similar to Promises (used in libraries like `co`).

---

## **8. Pre-ES6 Generators**

-   Before ES6, there were experimental generator implementations (e.g., SpiderMonkey).
-   Patterns like **async generator runners** (e.g., TJ Holowaychuk’s `co`) were popular.
-   ES6 standardized Generators, Promises, and made them interoperable.

---

# **Summary of Chapter 4**

-   Generators introduce **pausable functions** (via `yield`).
-   They enable **synchronous-looking async code** when combined with Promises.
-   Features covered:

    1. Breaking run-to-completion
    2. Yielding values
    3. Async iteration with generators
    4. Generators + Promises for clean async flow
    5. Delegation (`yield*`)
    6. Cooperative concurrency between generators
    7. Thunks as pre-Promise async tools
    8. Historical background (pre-ES6 usage)
