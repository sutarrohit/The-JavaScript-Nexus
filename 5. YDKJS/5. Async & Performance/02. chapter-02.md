# **Chapter 2 – Callbacks**

---

## **1. Callbacks – The Default Async Mechanism**

-   In JavaScript, **callbacks** are the fundamental mechanism to manage asynchronous tasks.
-   A callback is a function **passed into another function** to be called **later**.
-   Nearly every async pattern in JavaScript before Promises was built on callbacks.

**Example:**

```js
function fetchData(url, callback) {
    // async operation
    ajax(url, function (response) {
        callback(response);
    });
}

fetchData("/data", function (data) {
    console.log("Got data:", data);
});
```

---

## **2. Continuations**

-   A **continuation** is the rest of the program that should run after an async task finishes.
-   In callback-based code, the callback function is essentially the **continuation**.

**Example:**

```js
doA(function () {
    doB();
    doC();
});
```

-   Everything after `doA()` (in time) must be inside its callback — a continuation.

---

## **3. Sequential vs. Nested Callbacks**

-   When multiple async steps need to run **in sequence**, callbacks often nest.

**Example – Sequential steps:**

```js
step1(function (result1) {
    step2(result1, function (result2) {
        step3(result2, function (result3) {
            console.log(result3);
        });
    });
});
```

-   This leads to **callback nesting** or “callback hell”.

---

## **4. Inversion of Control**

-   **Inversion of Control (IoC)** occurs when you give a callback to another piece of code and **trust** it to:

    -   Call it exactly once.
    -   Pass the right parameters.
    -   Call it at the right time.

-   Once you hand over control, **you lose certainty** over execution behavior.

---

## **5. Problems with Callbacks**

### **5.1. Callback Hell (Pyramid of Doom)**

-   Deeply nested callbacks make code:

    -   Hard to read.
    -   Hard to maintain.
    -   Hard to debug.

### **5.2. Lack of Sequential Reasoning**

-   Code appears **out of order**.
-   Easy to misunderstand the actual execution sequence.

### **5.3. Inversion of Control Trust Issues**

-   The function you give your callback to might:

    -   Call it **too early** or **too late**.
    -   Call it **too many times** or **never**.
    -   Fail to handle exceptions thrown inside it.

---

## **6. Example of IoC Problems**

### **Too Many Calls**

```js
function asyncTask(cb) {
    cb(); // called once
    cb(); // oops, called again
}
```

### **Never Called**

```js
function asyncTask(cb) {
    // forgot to call cb()
}
```

### **Swallowed Exceptions**

```js
try {
    setTimeout(function () {
        throw new Error("Oops");
    }, 0);
} catch (err) {
    // Won’t catch because error happens asynchronously
}
```

---

## **7. Callback Conventions**

To reduce problems, developers often use conventions:

1. **Error-first callbacks** (Node.js style):

    - First parameter is an error (or `null` if no error).
    - Second parameter is the result.

    ```js
    function done(err, data) {
        if (err) {
            console.error(err);
            return;
        }
        console.log(data);
    }
    ```

2. **Never call callback synchronously** — always async.

---

## **8. Escaping Callback Hell**

-   **Modularization**: break into smaller functions.
-   **Named functions** instead of anonymous ones.
-   **Promise**-based APIs to replace raw callbacks.
-   **Async/Await** in modern JS for better sequential flow.

---

## **9. Summary**

-   Callbacks are powerful but come with **trust problems** and **readability issues**.
-   They are the root of many async headaches:

    -   **Inversion of Control**
    -   **Callback hell**
    -   **Error handling difficulties**

-   They paved the way for **Promises** (Chapter 3), which fix many of these issues.
