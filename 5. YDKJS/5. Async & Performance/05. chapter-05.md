# **Chapter 5 – Program Performance**

## **1. Performance Is Not Speed**

-   Performance in JavaScript isn’t only about “running faster.”
-   It’s about **optimizing the right things**:

    -   Perceived responsiveness.
    -   Efficient use of resources (CPU, memory, network).
    -   Smooth, interactive user experience.

---

## **2. Benchmarking**

-   To measure performance, you need **benchmarks**:

    -   Run code many times to average out anomalies.
    -   Use tools like `console.time()`, `performance.now()`, or Benchmark.js.

-   **Micro-benchmarks** (measuring very small code snippets) can be misleading:

    -   Engines optimize aggressively.
    -   A tiny gain in one place may not matter in overall app performance.

**Example:**

```js
console.time("loop");
for (let i = 0; i < 1e6; i++) {}
console.timeEnd("loop");
```

---

## **3. Writing Efficient JavaScript**

-   **Avoid Premature Optimization** → Don’t optimize without measurement.
-   **Algorithms matter more than syntax tricks**:

    -   Choosing the right data structure has a bigger effect than shaving off milliseconds.

-   Example: Sorting a large array efficiently matters more than whether you use `++i` or `i++`.

---

## **4. Garbage Collection (GC)**

-   JS has **automatic memory management**:

    -   Objects no longer referenced are eligible for GC.

-   Performance issues:

    -   Frequent allocations → more GC pauses.
    -   Long-lived objects in closures can leak memory if not cleared.

-   Best practices:

    -   Reuse objects where possible.
    -   Avoid creating unnecessary temporary objects in tight loops.

---

## **5. Scope & Closures Performance**

-   Variables in inner scopes require more lookup steps.
-   Closures can hold memory longer than necessary.
-   Minimize closures in hot paths (but don’t avoid them where needed for clarity).

---

## **6. Async Performance**

-   Async doesn’t always mean faster — it means **non-blocking**.
-   Benefits:

    -   Keeps UI responsive.
    -   Allows concurrent waiting for I/O.

-   Example:

```js
async function loadData() {
    let [user, posts] = await Promise.all([fetch("/user"), fetch("/posts")]);
}
```

-   Both fetches happen in parallel → faster overall completion.

---

## **7. Parallelism with Web Workers**

-   JS is single-threaded, but **Web Workers** allow running scripts in background threads.
-   Workers don’t share memory; communicate via **message passing**.
-   Good for CPU-intensive tasks (image processing, cryptography, etc.).

```js
var worker = new Worker("worker.js");
worker.postMessage({ num: 100000 });
worker.onmessage = (e) => console.log("Result:", e.data);
```

---

## **8. Optimizing Rendering Performance**

-   In browsers, **60 FPS = \~16ms per frame**.
-   Main thread must handle:

    -   JavaScript execution
    -   Layout & style recalculation
    -   Painting & compositing

-   Bottlenecks:

    -   Large DOM manipulation in a single frame.
    -   Forced reflows (`offsetHeight`, etc.).

-   Tips:

    -   Batch DOM updates.
    -   Use `requestAnimationFrame()` for visual updates.

---

## **9. Network Performance**

-   Network is often the **biggest bottleneck**.
-   Optimizations:

    -   Minify/compress JS & CSS.
    -   Use caching headers.
    -   Lazy-load resources when needed.
    -   Use CDNs for faster delivery.

---

## **10. Profiling Tools**

-   Browsers provide powerful dev tools:

    -   **Performance tab (Chrome/Firefox)** → record flame charts of execution.
    -   **Memory profiling** → detect leaks.
    -   **Network tab** → measure resource loading times.

---

## **11. Holistic View**

-   Performance is not just code speed, but **system performance**:

    -   CPU utilization
    -   Memory footprint
    -   Battery drain (on mobile)
    -   User perception (responsiveness vs. raw time)

---

# **Summary of Chapter 5**

-   Performance ≠ raw speed — it’s about **efficiency + perception**.
-   Measure before optimizing; avoid premature tweaks.
-   Focus on:

    1. Algorithmic efficiency
    2. Memory management (GC awareness)
    3. Async concurrency for responsiveness
    4. Parallelism via Web Workers for CPU-heavy tasks
    5. Render pipeline optimizations
    6. Network delivery efficiency

-   Use profiling tools to find **real bottlenecks** before changing code.
