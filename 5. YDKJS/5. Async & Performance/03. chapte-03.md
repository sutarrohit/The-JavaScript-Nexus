# **Chapter 3 – Promises**

## **1. Motivation for Promises**

-   **Callbacks are fragile**:

    -   Inversion of Control → you trust another function to call your callback correctly.
    -   Callback hell → deeply nested structures for sequential async flows.
    -   Error handling is inconsistent → try/catch doesn’t cross async boundaries.

-   **Promises** were introduced in ES6 to address these issues:

    -   They are **composable**, **trustworthy**, and **predictable**.
    -   Provide a **standardized mechanism** for async return values.

---

## **2. What is a Promise?**

-   A **Promise** is a **future value** placeholder.
-   Instead of passing callbacks into functions, you **return a Promise** and attach callbacks to it later.
-   Core idea: _“Don’t call me, I’ll call you back… reliably.”_

---

## **3. States of a Promise**

A Promise has exactly three states:

1. **Pending** → initial state, not settled.
2. **Fulfilled** → operation succeeded, has a value.
3. **Rejected** → operation failed, has a reason (error).

-   Once settled (fulfilled or rejected), a Promise is **immutable** — it never changes again.
-   This one-way transition is what makes Promises trustworthy.

---

## **4. Creating Promises**

```js
var p = new Promise(function (resolve, reject) {
    // Async operation
    setTimeout(() => resolve("Done!"), 1000);
});
```

-   The executor function is called immediately with two callbacks:

    -   `resolve(value)` → marks promise fulfilled.
    -   `reject(error)` → marks promise rejected.

-   Throwing inside the executor automatically calls `reject(error)`.

---

## **5. Consuming Promises**

```js
p.then(
    (value) => console.log("Fulfilled:", value),
    (error) => console.error("Rejected:", error)
);
```

-   `.then(onFulfilled, onRejected)` attaches handlers.
-   Both are optional; if omitted, the result passes through unchanged.
-   `.catch(onRejected)` is shorthand for `.then(null, onRejected)`.

---

## **6. Thenable Duck-Typing**

-   A **thenable** is any object with a `.then()` method.
-   Promises “assimilate” thenables by adopting their state.
-   This enables interoperability with libraries that implement their own promise-like systems.

---

## **7. Promise Guarantees**

Unlike callbacks, Promises give strong guarantees:

1. **Call once** → handlers fire exactly one time.
2. **Always async** → handlers are queued for future event loop ticks (via **Job Queue**).
3. **Immutable state** → once settled, it never changes.
4. **Error propagation** → exceptions thrown inside `.then()` handlers automatically turn into rejections.

---

## **8. Chaining Promises**

-   `.then()` always returns a new Promise.
-   Enables sequential flow without nesting.

```js
p.then((result) => result + "!")
    .then((result) => result.toUpperCase())
    .then(console.log); // "DONE!"
```

-   Each `.then()` step transforms the value for the next.

---

## **9. Error Handling**

-   Errors bubble down the chain until caught.

```js
p.then((result) => {
    throw new Error("Oops!");
}).catch((err) => {
    console.error("Caught:", err);
});
```

-   Important: if no `.catch()` is attached, rejection produces an **Unhandled Promise Rejection** (warning or crash in Node.js).

---

## **10. Promise Patterns**

### **10.1. Promise.all()**

-   Waits for all promises in an array to settle.
-   Resolves with an array of values if all succeed.
-   Rejects immediately if **any one** rejects.

```js
Promise.all([p1, p2, p3])
    .then((results) => console.log(results))
    .catch((err) => console.error(err));
```

### **10.2. Promise.race()**

-   Resolves/rejects as soon as the **first** promise settles.

```js
Promise.race([p1, p2]).then((result) => console.log("First result:", result));
```

### **10.3. Promise.resolve()**

-   Creates a resolved Promise from a value (or thenable).

```js
Promise.resolve(42).then(console.log); // 42
```

### **10.4. Promise.reject()**

-   Creates a rejected Promise.

```js
Promise.reject("Error!").catch(console.error);
```

---

## **11. Promise Trust vs Callbacks**

-   With callbacks:

    -   Might be called too early, too late, too many times, or never.
    -   Exceptions can be swallowed silently.

-   With Promises:

    -   Guaranteed exactly once.
    -   Errors are automatically captured and propagated.
    -   Async timing is consistent.

---

## **12. Promise Limitations**

-   Still only represent a **single value** (cannot stream multiple values).
-   Not cancelable by design (once started, can’t stop the async work).
-   Can still lead to complex flow control in larger apps.
-   Later features (`async/await`, Observables) build on Promises to overcome these limitations.

---

## **13. Example – Sequential Async Without Hell**

**With callbacks:**

```js
doA(function (a) {
    doB(a, function (b) {
        doC(b, function (c) {
            console.log(c);
        });
    });
});
```

**With Promises:**

```js
doA().then(doB).then(doC).then(console.log).catch(console.error);
```

-   Cleaner, flatter, and easier to maintain.

---

## **14. Example – Parallel Async**

```js
Promise.all([getUser(), getOrders(), getBalance()]).then(([user, orders, balance]) => {
    console.log(user, orders, balance);
});
```

-   All requests happen simultaneously.
-   Only proceeds once all results are ready.

---

## **15. Summary**

-   Promises solve the **trust problem** of callbacks.
-   They provide **predictability** through guarantees:

    -   Call once
    -   Always async
    -   Immutable state

-   They support **compositional patterns** (`all`, `race`) and chaining.
-   They are not perfect (single value, no cancellation), but they are the **foundation of modern async JS**, paving the way for **async/await**.
