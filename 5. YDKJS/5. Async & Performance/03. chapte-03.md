# **Chapter 3 – Promises**

---

## **1. What is a Promise?**

-   A **Promise** is an object that represents the **eventual completion** or **failure** of an asynchronous operation.
-   It acts as a **future value** placeholder — something you can work with _before_ the actual value is ready.
-   Instead of handing over control (as with callbacks), you get a value-like object that you can observe and chain.

---

## **2. States of a Promise**

A Promise can be in one of three states:

1. **Pending** → initial state; neither fulfilled nor rejected.
2. **Fulfilled** → operation completed successfully (`.then()` success handler runs).
3. **Rejected** → operation failed (`.then()` failure handler or `.catch()` runs).

Once fulfilled or rejected, a Promise is **settled** and cannot change state again.

---

## **3. Creating a Promise**

```js
var p = new Promise(function (resolve, reject) {
    setTimeout(function () {
        resolve("Success!");
    }, 1000);
});
```

-   `resolve(value)` → fulfills the promise.
-   `reject(reason)` → rejects the promise.

---

## **4. Consuming a Promise**

```js
p.then(
    function (value) {
        console.log(value);
    },
    function (error) {
        console.error(error);
    }
);
```

-   `.then()` takes **two callbacks**:

    -   First → for fulfillment.
    -   Second → for rejection.

-   Either can be omitted.

---

## **5. Promise Chaining**

-   `.then()` returns a new Promise, allowing you to chain operations.

```js
p.then((result) => result + "!").then((result) => console.log(result));
```

-   Chains allow **sequential async flows** without nesting callbacks.

---

## **6. Error Handling**

-   Errors propagate through the chain until caught.

```js
p.then((result) => {
    throw new Error("Oops");
}).catch((err) => {
    console.error(err);
});
```

-   `.catch()` is shorthand for `.then(null, errorHandler)`.

---

## **7. Promise Guarantees**

Promises have strong guarantees compared to callbacks:

1. **Call once** → fulfillment/rejection handlers run exactly once.
2. **Always async** → `.then()` callbacks never run synchronously, even if already resolved.
3. **Immutable state** → once settled, the state/value never changes.

---

## **8. Promise Trust**

-   With callbacks, you rely on external code to call at the right time.
-   With Promises, the API guarantees:

    -   Only one resolution/rejection.
    -   Errors won’t be swallowed silently.
    -   Execution timing is predictable.

---

## **9. Composing Promises**

### **9.1. Promise.all**

-   Runs multiple promises in parallel; waits for all to fulfill.

```js
Promise.all([p1, p2]).then((results) => {
    console.log(results); // array of results
});
```

-   Rejects if **any** promise rejects.

### **9.2. Promise.race**

-   Resolves/rejects with the first promise that settles.

```js
Promise.race([p1, p2]).then((result) => {
    console.log(result);
});
```

---

## **10. Promise Resolution**

-   A Promise can be resolved with:

    -   A value.
    -   Another Promise.
    -   A thenable (object with `.then` method).

-   If resolved with another Promise, it adopts that Promise’s state.

---

## **11. Pitfalls**

-   Forgetting to `return` inside `.then()` can break chaining.
-   Not handling rejections → results in **unhandled promise rejections**.

---

## **12. Transition from Callbacks to Promises**

-   Promises are a cleaner, more reliable way to handle async than callbacks.
-   Still require understanding of async flow, but remove most Inversion of Control issues.

---

## **13. Summary**

-   Promises solve many callback issues:

    -   Eliminate “callback hell” via chaining.
    -   Provide trustable guarantees.
    -   Support powerful composition with `all` and `race`.

-   They are the **foundation** for `async/await` (covered in later chapters).
