# Chapter 4: Coercion

## 1. What Is Coercion?

-   **Coercion** = converting a value from one type to another.
-   Two kinds:

    1. **Explicit Coercion** → obvious conversion (`String(123)`, `Boolean(0)`).
    2. **Implicit Coercion** → conversion happens automatically by the engine (e.g., `"5" * 2 → 10`).

Many developers consider coercion a “bad” part of JS, but it’s actually powerful if understood well.

---

## 2. Converting Values

### String ↔ Number

-   Explicit:

    ```js
    let num = Number("42"); // 42
    let str = String(42); // "42"
    ```

-   Implicit:

    ```js
    "5" * 2; // 10  ("5" → number)
    "5" + 2; // "52" (2 → string)
    ```

### String ↔ Boolean

-   Explicit:

    ```js
    Boolean(""); // false
    Boolean("hi"); // true
    ```

-   Implicit:

    ```js
    if ("hello") console.log("truthy"); // prints
    ```

### Number ↔ Boolean

-   Explicit:

    ```js
    Boolean(0); // false
    Boolean(1); // true
    ```

-   Implicit:

    ```js
    if (0) console.log("no"); // skipped
    ```

---

## 3. Abstract Value Operations

JS defines internal abstract operations that govern coercion. Some important ones:

### ToString

-   Converts values to strings.

    ```js
    String(null); // "null"
    String(undefined); // "undefined"
    String(true); // "true"
    String(42); // "42"
    ```

### ToNumber

-   Converts values to numbers.

    ```js
    Number("123"); // 123
    Number(""); // 0
    Number(null); // 0
    Number(undefined); // NaN
    Number(true); // 1
    Number(false); // 0
    ```

### ToBoolean (truthy/falsy)

-   Only 7 falsy values in JS:

    -   `undefined`, `null`, `false`, `+0`, `-0`, `NaN`, `""` (empty string)

-   Everything else is truthy (including objects, arrays, `"0"`, `"false"`).

### ToPrimitive

-   Objects must be converted to primitive before some operations.
-   Uses `valueOf()` or `toString()` depending on context.

    ```js
    let obj = { valueOf: () => 42 };
    console.log(obj + 1); // 43
    ```

---

## 4. Explicit Coercion

-   **String conversion**:

    ```js
    String(123); // "123"
    (123).toString(); // "123"
    JSON.stringify([1, 2, 3]); // "[1,2,3]"
    ```

-   **Number conversion**:

    ```js
    Number("123"); // 123
    parseInt("123", 10); // 123
    +"123"; // 123
    ```

-   **Boolean conversion**:

    ```js
    Boolean(0); // false
    !!"hello"; // true
    ```

These are straightforward and predictable.

---

## 5. Implicit Coercion

Implicit coercion happens in operations where types “don’t match.”

### String Context (`+` operator)

-   If either operand is a string, the other is coerced to string:

    ```js
    "The answer is " + 42; // "The answer is 42"
    "Hello " + true; // "Hello true"
    ```

### Number Context (`-`, `*`, `/`)

-   Non-numbers are coerced to numbers:

    ```js
    "5" - 2; // 3
    "5" * 2; // 10
    true + 1; // 2
    ```

### Boolean Context (conditionals)

-   Any value in `if`, `while`, `for`, `?:` is coerced to boolean.

    ```js
    if ("0") console.log("truthy"); // prints, because "0" is non-empty
    ```

---

## 6. Loose vs Strict Equality

### Strict Equality (`===`)

-   No coercion, types must match.

    ```js
    42 === "42"; // false
    ```

### Loose Equality (`==`)

-   Allows coercion before comparison.

    ```js
    42 == "42"; // true
    1 == true; // true
    ```

Some confusing cases:

```js
"" == 0; // true
false == 0; // true
null == undefined; // true
[] == ""; // true
[] == 0; // true
[1] == 1; // true
```

Rule: `==` is not always bad — it has **well-defined rules**. But it requires careful understanding.

---

## 7. Abstract Relational Comparison (`<`, `>`)

-   When comparing different types, coercion occurs.
-   Example:

    ```js
    "5" < 10; // true ("5" → 5)
    "abc" < 10; // false ("abc" → NaN)
    ```

-   Special case: strings compared lexicographically.

    ```js
    "22" < "3"; // true (string comparison)
    ```

---

## 8. Special Coercion Cases

### Objects to Primitives

-   Objects first try `valueOf()`, then `toString()`.

    ```js
    let obj = {
        toString: () => "hello",
        valueOf: () => 42
    };

    console.log(obj + ""); // "42" (number context)
    console.log(String(obj)); // "hello"
    ```

### Arrays

-   `toString()` flattens array to comma-separated string:

    ```js
    [1, 2, 3].toString(); // "1,2,3"
    [] + []; // ""  (two empty strings)
    [] + {}; // "[object Object]"
    ```

### Dates

-   Special: prefer `toString()` over `valueOf()`.

    ```js
    let d = new Date(0);
    console.log(d + 1); // "Thu Jan 01 1970...1"
    ```

---

## 9. Coercion Pitfalls

1. `[] == ![]`

    - `![]` → false
    - `[] == false`
    - `[]` → "" → 0
    - `false` → 0
    - `0 == 0` → true

2. `[] + {}`

    - `[]` → ""
    - `{} → "[object Object]"`
    - Result: `"[object Object]"`

3. `{} + []`

    - Treated as a block + array → `0`

---

## 10. Coercion Guidelines

Use explicit coercion when clarity is needed.
Use `==` only when:

-   You allow both `null` and `undefined` (e.g., `if (a == null)` checks both).
-   You fully understand type conversion rules.

Avoid coercion-heavy “tricks” — they reduce readability.

---

## 11. Review

-   Coercion = type conversion (explicit or implicit).
-   Abstract operations (`ToString`, `ToNumber`, `ToBoolean`, `ToPrimitive`) define how values convert.
-   Explicit coercion = predictable (`String(..)`, `Number(..)`, `Boolean(..)`).
-   Implicit coercion happens in `+`, math ops, conditionals, `==`.
-   Loose equality (`==`) uses coercion → can be useful if rules are understood.
-   Edge cases (`[] == 0`, `null == undefined`, `[] + {}`) come from consistent but tricky coercion rules.
-   Best practice: embrace coercion with clarity, avoid confusing hacks.

---

---

# JS Type Coercion Rules

### 1. Coercion in Addition (`+`)

The `+` operator is special:

-   If either operand is a **string**, the other is converted to a string → **String concatenation**.
-   Otherwise → **Numeric addition**.

#### Rules:

1. **String + Number** → Number converted to String

    ```js
    "5" + 2; // "52"
    ```

2. **String + Boolean** → Boolean converted to String

    ```js
    "hello" + true; // "hellotrue"
    ```

3. **String + Object** → Object converted with `.toString()`

    ```js
    "value: " + [1, 2]; // "value: 1,2"
    ```

4. **Number + Boolean** → Boolean converted to Number (`true → 1`, `false → 0`)

    ```js
    5 + true; // 6
    ```

5. **Number + null** → `null → 0`

    ```js
    5 + null; // 5
    ```

6. **Number + undefined** → `undefined → NaN`

    ```js
    5 + undefined; // NaN
    ```

7. **Boolean + Boolean** → Both converted to Numbers

    ```js
    true + false; // 1
    ```

---

### 2. Coercion in Subtraction, Multiplication, Division (`- * / %`)

These operators **always convert operands to numbers**.

#### Rules:

1. **String - Number** → String converted to Number

    ```js
    "10" - 2; // 8
    ```

2. **String \* String** → Both converted to Numbers

    ```js
    "5" * "2"; // 10
    ```

3. **Boolean used** → Converted to Number (`true → 1`, `false → 0`)

    ```js
    true * 5; // 5
    false - 3; // -3
    ```

4. **null** → `0`

    ```js
    null * 5; // 0
    ```

5. **undefined** → `NaN`

    ```js
    undefined + 1; // NaN
    ```

---

### 3. Equality (`==`) Coercion

Loose equality (`==`) converts values before comparing.

### Rules:

1. **Number == String** → String converted to Number

    ```js
    5 == "5"; // true
    ```

2. **Boolean == Number** → Boolean converted to Number

    ```js
    true == 1; // true
    false == 0; // true
    ```

3. **null == undefined** → `true`

    ```js
    null == undefined; // true
    ```

4. **null/undefined with anything else** → `false`

    ```js
    null == 0; // false
    ```

5. **Object == Primitive** → Object converted via `valueOf()` or `toString()`

    ```js
    [1, 2] == "1,2"; // true
    ```

---

### 4. Strict Equality (`===`)

-   **No coercion happens**. Types must match.

    ```js
    5 === "5"; // false
    ```

---

### 5. Logical Operators (`&&`, `||`, `!`)

-   Operands are converted to **Boolean** for evaluation.
-   But return **original value**, not strictly `true/false`.

#### Rules:

1. **Falsy values**: `false, 0, -0, 0n, "", null, undefined, NaN`
   Everything else is truthy.

2. `a || b` → If `a` is truthy, return `a`; else return `b`.

    ```js
    "hi" || 0; // "hi"
    ```

3. `a && b` → If `a` is falsy, return `a`; else return `b`.

    ```js
    0 && "hi"; // 0
    ```

4. `!a` → Converts `a` to Boolean, then negates.

    ```js
    !"hello"; // false
    ```

---

---
