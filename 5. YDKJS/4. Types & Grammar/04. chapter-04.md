# Chapter 4: Coercion — Detailed Notes

## 1. What Is Coercion?

-   **Coercion** = converting a value from one type to another.
-   Two kinds:

    1. **Explicit Coercion** → obvious conversion (`String(123)`, `Boolean(0)`).
    2. **Implicit Coercion** → conversion happens automatically by the engine (e.g., `"5" * 2 → 10`).

Many developers consider coercion a “bad” part of JS, but it’s actually powerful if understood well.

---

## 2. Converting Values

### String ↔ Number

-   Explicit:

    ```js
    let num = Number("42"); // 42
    let str = String(42); // "42"
    ```

-   Implicit:

    ```js
    "5" * 2; // 10  ("5" → number)
    "5" + 2; // "52" (2 → string)
    ```

### String ↔ Boolean

-   Explicit:

    ```js
    Boolean(""); // false
    Boolean("hi"); // true
    ```

-   Implicit:

    ```js
    if ("hello") console.log("truthy"); // prints
    ```

### Number ↔ Boolean

-   Explicit:

    ```js
    Boolean(0); // false
    Boolean(1); // true
    ```

-   Implicit:

    ```js
    if (0) console.log("no"); // skipped
    ```

---

## 3. Abstract Value Operations

JS defines internal abstract operations that govern coercion. Some important ones:

### ToString

-   Converts values to strings.

    ```js
    String(null); // "null"
    String(undefined); // "undefined"
    String(true); // "true"
    String(42); // "42"
    ```

### ToNumber

-   Converts values to numbers.

    ```js
    Number("123"); // 123
    Number(""); // 0
    Number(null); // 0
    Number(undefined); // NaN
    Number(true); // 1
    Number(false); // 0
    ```

### ToBoolean (truthy/falsy)

-   Only 7 falsy values in JS:

    -   `undefined`, `null`, `false`, `+0`, `-0`, `NaN`, `""` (empty string)

-   Everything else is truthy (including objects, arrays, `"0"`, `"false"`).

### ToPrimitive

-   Objects must be converted to primitive before some operations.
-   Uses `valueOf()` or `toString()` depending on context.

    ```js
    let obj = { valueOf: () => 42 };
    console.log(obj + 1); // 43
    ```

---

## 4. Explicit Coercion

-   **String conversion**:

    ```js
    String(123); // "123"
    (123).toString(); // "123"
    JSON.stringify([1, 2, 3]); // "[1,2,3]"
    ```

-   **Number conversion**:

    ```js
    Number("123"); // 123
    parseInt("123", 10); // 123
    +"123"; // 123
    ```

-   **Boolean conversion**:

    ```js
    Boolean(0); // false
    !!"hello"; // true
    ```

These are straightforward and predictable.

---

## 5. Implicit Coercion

Implicit coercion happens in operations where types “don’t match.”

### String Context (`+` operator)

-   If either operand is a string, the other is coerced to string:

    ```js
    "The answer is " + 42; // "The answer is 42"
    "Hello " + true; // "Hello true"
    ```

### Number Context (`-`, `*`, `/`)

-   Non-numbers are coerced to numbers:

    ```js
    "5" - 2; // 3
    "5" * 2; // 10
    true + 1; // 2
    ```

### Boolean Context (conditionals)

-   Any value in `if`, `while`, `for`, `?:` is coerced to boolean.

    ```js
    if ("0") console.log("truthy"); // prints, because "0" is non-empty
    ```

---

## 6. Loose vs Strict Equality

### Strict Equality (`===`)

-   No coercion, types must match.

    ```js
    42 === "42"; // false
    ```

### Loose Equality (`==`)

-   Allows coercion before comparison.

    ```js
    42 == "42"; // true
    1 == true; // true
    ```

Some confusing cases:

```js
"" == 0; // true
false == 0; // true
null == undefined; // true
[] == ""; // true
[] == 0; // true
[1] == 1; // true
```

Rule: `==` is not always bad — it has **well-defined rules**. But it requires careful understanding.

---

## 7. Abstract Relational Comparison (`<`, `>`)

-   When comparing different types, coercion occurs.
-   Example:

    ```js
    "5" < 10; // true ("5" → 5)
    "abc" < 10; // false ("abc" → NaN)
    ```

-   Special case: strings compared lexicographically.

    ```js
    "22" < "3"; // true (string comparison)
    ```

---

## 8. Special Coercion Cases

### Objects to Primitives

-   Objects first try `valueOf()`, then `toString()`.

    ```js
    let obj = {
        toString: () => "hello",
        valueOf: () => 42
    };

    console.log(obj + ""); // "42" (number context)
    console.log(String(obj)); // "hello"
    ```

### Arrays

-   `toString()` flattens array to comma-separated string:

    ```js
    [1, 2, 3].toString(); // "1,2,3"
    [] + []; // ""  (two empty strings)
    [] + {}; // "[object Object]"
    ```

### Dates

-   Special: prefer `toString()` over `valueOf()`.

    ```js
    let d = new Date(0);
    console.log(d + 1); // "Thu Jan 01 1970...1"
    ```

---

## 9. Coercion Pitfalls

1. `[] == ![]`

    - `![]` → false
    - `[] == false`
    - `[]` → "" → 0
    - `false` → 0
    - `0 == 0` → true

2. `[] + {}`

    - `[]` → ""
    - `{} → "[object Object]"`
    - Result: `"[object Object]"`

3. `{} + []`

    - Treated as a block + array → `0`

---

## 10. Coercion Guidelines

Use explicit coercion when clarity is needed.
Use `==` only when:

-   You allow both `null` and `undefined` (e.g., `if (a == null)` checks both).
-   You fully understand type conversion rules.

Avoid coercion-heavy “tricks” — they reduce readability.

---

## 11. Review

-   Coercion = type conversion (explicit or implicit).
-   Abstract operations (`ToString`, `ToNumber`, `ToBoolean`, `ToPrimitive`) define how values convert.
-   Explicit coercion = predictable (`String(..)`, `Number(..)`, `Boolean(..)`).
-   Implicit coercion happens in `+`, math ops, conditionals, `==`.
-   Loose equality (`==`) uses coercion → can be useful if rules are understood.
-   Edge cases (`[] == 0`, `null == undefined`, `[] + {}`) come from consistent but tricky coercion rules.
-   Best practice: embrace coercion with clarity, avoid confusing hacks.
