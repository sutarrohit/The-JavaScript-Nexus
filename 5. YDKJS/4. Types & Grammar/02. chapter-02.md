# Chapter 2: Values ‚Äî Detailed Notes (Expanded)

## 1. Arrays

### Characteristics

-   Arrays in JS are **specialized objects** with **numeric indexes**.
-   Can hold any type of value (heterogeneous arrays allowed):

    ```js
    let a = [1, "two", { x: 3 }, [4, 5]];
    ```

-   Dynamic: no pre-sizing required; size adjusts automatically.

### `delete` and length

-   Removing values with `delete` does not shrink `.length`:

    ```js
    let arr = [1, 2, 3];
    delete arr[2];
    console.log(arr); // [1, 2, <empty>]
    console.log(arr.length); // 3
    ```

-   To remove elements properly, use `.splice()`.

### Sparse Arrays

-   Arrays can have ‚Äúholes‚Äù (unassigned indexes):

    ```js
    let arr = [];
    arr[0] = 1;
    arr[2] = 3;

    console.log(arr[1]); // undefined
    console.log(arr.length); // 3
    ```

-   Difference: slot not explicitly set to `undefined`.
-   Impacts iteration methods like `.map()` and `.forEach()` ‚Äî they skip holes.

### Arrays as Objects

-   Arrays are objects, so they can have string keys:

    ```js
    let arr = [1, 2];
    arr["foo"] = "bar";
    console.log(arr.length); // 2
    console.log(arr.foo); // "bar"
    ```

If a string key looks like a number, it becomes an index:

```js
let arr = [];
arr["13"] = "hi";
console.log(arr.length); // 14
```

Best practice: use **arrays only for numeric keys**.

---

## 2. Array-Likes

-   **Array-like objects** look like arrays but aren‚Äôt true arrays.

    -   Examples: `arguments`, DOM NodeLists, strings.

### Conversion Techniques

1. Using `slice(..)`:

    ```js
    function foo() {
        let arr = Array.prototype.slice.call(arguments);
        console.log(arr);
    }
    foo(1, 2, 3); // [1,2,3]
    ```

2. Using ES6 `Array.from(..)`:

    ```js
    let arr = Array.from(document.querySelectorAll("div"));
    ```

3. Using spread operator (ES6):

    ```js
    function bar(...args) {
        console.log(args); // already a true array
    }
    bar(1, 2, 3);
    ```

---

## 3. Strings

### Similarities with Arrays

-   Strings have:

    -   `.length`
    -   Indexed character access
    -   `.indexOf()`, `.concat()`

-   Example:

    ```js
    let str = "hello";
    console.log(str[1]); // "e"
    ```

### Differences

1. **Immutable**:

    ```js
    let str = "hello";
    str[1] = "a";
    console.log(str); // "hello" (unchanged)
    ```

2. **Array mutator methods don‚Äôt apply**:

    ```js
    "hello".push("!"); // TypeError
    ```

3. **Workaround by converting to array**:

    ```js
    let str = "hello";
    let reversed = str.split("").reverse().join("");
    console.log(reversed); // "olleh"
    ```

4. **Unicode Pitfalls**:

    - Characters outside BMP (astral symbols like emoji) are stored as **surrogate pairs**.
    - Example:

        ```js
        let s = "üòÄ";
        console.log(s.length); // 2 (not 1!)
        ```

    - Requires special Unicode-aware libraries (e.g., Mathias Bynens‚Äô _Esrever_).

Rule: Use strings for textual data, arrays for character-level manipulation.

---

## 4. Numbers

### General

-   Only one numeric type: `number` (IEEE 754 double precision).
-   Covers both integers and floats.

### Numeric Syntax

-   Decimal:

    ```js
    let a = 42;
    let b = 42.3;
    ```

-   Optional leading/trailing parts:

    ```js
    let c = 0.42; // valid
    let d = 42; // valid but uncommon
    ```

-   Exponent form:

    ```js
    let big = 5e6; // 5000000
    let small = 1e-3; // 0.001
    ```

-   Binary, Octal, Hex (ES6+):

    ```js
    0b1010; // 10
    0o52; // 42
    0x2a; // 42
    ```

---

### Floating-Point Issues

-   Classic case:

    ```js
    0.1 + 0.2 === 0.3; // false
    ```

-   Actual result: `0.30000000000000004`

#### Fix: Use tolerance comparison

```js
function closeEnough(x, y) {
    return Math.abs(x - y) < Number.EPSILON;
}
closeEnough(0.1 + 0.2, 0.3); // true
```

---

### Safe Integers

-   Largest reliably safe integer: `2^53 - 1 = 9007199254740991`

    -   `Number.MAX_SAFE_INTEGER`
    -   `Number.MIN_SAFE_INTEGER`

-   Example:

    ```js
    Number.isSafeInteger(9007199254740991); // true
    Number.isSafeInteger(9007199254740992); // false
    ```

For larger integers, use **BigInt** (ES2020).

---

### Integer Testing

```js
Number.isInteger(42); // true
Number.isInteger(42.0); // true
Number.isInteger(42.3); // false
```

Polyfill for pre-ES6:

```js
Number.isInteger = function (num) {
    return typeof num === "number" && num % 1 === 0;
};
```

---

### 32-bit Signed Integers

-   Bitwise operators (`|`, `&`, etc.) force values into **32-bit signed integer range**:

    -   From `-2^31` to `2^31 - 1` ‚Üí -2147483648 to 2147483647.

-   Example:

    ```js
    console.log(2147483647 | 0); // 2147483647
    console.log(2147483648 | 0); // -2147483648
    ```

---

## 5. Special Values

### `null` and `undefined`

-   `undefined` = variable declared but no value.
-   `null` = explicit ‚Äúno value.‚Äù

Philosophical distinction:

-   `undefined` ‚Üí not yet assigned.
-   `null` ‚Üí explicitly empty.

---

### `void` Operator

-   Always evaluates to `undefined`:

    ```js
    console.log(void 0); // undefined
    ```

-   Use to avoid unintended values:

    ```js
    return void setTimeout(task, 100);
    ```

---

### `NaN`

-   Result of invalid math operations:

    ```js
    let x = 2 / "foo"; // NaN
    typeof x; // "number"
    ```

-   Special property: not equal to itself:

    ```js
    NaN === NaN; // false
    ```

#### Checking for NaN

-   Bad: `isNaN(..)` (buggy, coerces input).

    ```js
    isNaN("foo"); // true (!)
    ```

-   Good: `Number.isNaN(..)` (ES6).

    ```js
    Number.isNaN(2 / "foo"); // true
    Number.isNaN("foo"); // false
    ```

-   Polyfill:

    ```js
    Number.isNaN = function (n) {
        return n !== n;
    };
    ```

---

### Infinity

-   Division by zero:

    ```js
    1 / 0; // Infinity
    -1 / 0; // -Infinity
    ```

-   Constants:

    -   `Number.POSITIVE_INFINITY`
    -   `Number.NEGATIVE_INFINITY`

---

## 6. Review

-   **Arrays**: dynamic, sparse slots, best used with numeric indexes only.
-   **Strings**: immutable, array-like but not arrays, Unicode quirks.
-   **Numbers**: only one type (floating point), precision issues, safe integer ranges, 32-bit behavior with bitwise ops.
-   **Special Values**:

    -   `undefined` (not yet assigned)
    -   `null` (explicitly empty)
    -   `NaN` (invalid number, never equal to itself)
    -   `Infinity` (well-defined overflow)
    -   `void` (always `undefined`).
