# Chapter 2: Values — Detailed Notes

## 1. Overview

-   **Values** are the actual data stored in variables.
-   In JavaScript, arrays, strings, and numbers are the **fundamental building blocks**.
-   However, JS treats them differently compared to other languages:

    -   Arrays can hold _any type_.
    -   Strings look like arrays but are **immutable**.
    -   Numbers are **floating-point**, not true integers.

-   Also includes **special values**: `null`, `undefined`, `NaN`, `Infinity`.

---

## 2. Arrays

### Characteristics

-   Containers for any type of value:

    ```js
    let arr = [1, "2", [3]];
    arr.length; // 3
    arr[2][0]; // 3
    ```

-   **No fixed size**: Arrays grow dynamically.

-   `delete` removes an element but doesn’t adjust `.length`.

### Sparse Arrays

-   Leaving “holes” creates confusion:

    ```js
    let a = [];
    a[0] = 1;
    a[2] = 3;
    console.log(a[1]); // undefined
    a.length; // 3
    ```

    -   Empty slots behave differently than explicitly setting `undefined`.

### Arrays as Objects

-   Arrays are objects with numeric keys.
-   They can also have string keys:

    ```js
    let a = [];
    a[0] = 1;
    a["foo"] = 2;
    console.log(a.length); // 1
    console.log(a.foo); // 2
    ```

If a string key is coercible to a number:

```js
let a = [];
a["13"] = 42;
a.length; // 14
```

**Best practice**: use arrays for numeric indexing, objects for key-value storage.

---

## 3. Array-Likes

-   Certain values are _array-like_ but not true arrays:

    -   `arguments` object
    -   DOM NodeLists

-   Need conversion for array methods:

    ```js
    function foo() {
        let arr = Array.prototype.slice.call(arguments);
        arr.push("extra");
        console.log(arr);
    }
    foo("a", "b"); // ["a","b","extra"]
    ```

-   ES6+ provides:

    ```js
    let arr = Array.from(arguments);
    ```

---

## 4. Strings

-   **Strings ≠ arrays of characters** (though similar in appearance).
    Example:

    ```js
    let str = "foo";
    let arr = ["f", "o", "o"];
    ```

### Similarities

-   Both have `.length`.
-   Both support `indexOf`, `concat`.
-   Can access characters with `[index]` (ES5+).

### Key Differences

1. **Immutability**:

    ```js
    let str = "foo";
    str[1] = "O";
    console.log(str); // "foo" (unchanged)

    let arr = ["f", "o", "o"];
    arr[1] = "O";
    console.log(arr); // ["f","O","o"]
    ```

2. **Methods**:

    - String operations return **new strings**.
    - Array operations (e.g., `push`, `reverse`) modify in-place.

3. **Borrowing methods**:

    ```js
    let str = "foo";
    let joined = Array.prototype.join.call(str, "-");
    // "f-o-o"
    ```

### Reversing a String (Workaround)

```js
let str = "foo";
let reversed = str.split("").reverse().join("");
// "oof"
```

Doesn’t handle Unicode astral symbols correctly.

If you often need array-like operations → store as **array of chars** instead of string.

---

## 5. Numbers

### General

-   JS has **only one numeric type**: `number`.
-   Based on **IEEE 754 double-precision floating point**.
-   No distinct integer type.

### Literals

-   Decimal, exponential, binary, octal, hexadecimal.

    ```js
    let a = 42; // decimal
    let b = 5e3; // 5000
    let c = 0b1010; // binary → 10
    let d = 0o52; // octal → 42
    let e = 0x2a; // hex → 42
    ```

### Floating-Point Issues

-   Classic problem:

    ```js
    0.1 + 0.2 === 0.3; // false
    ```

-   Reason: binary floating-point precision.
-   Workaround: compare with tolerance:

    ```js
    function nearlyEqual(a, b) {
        return Math.abs(a - b) < Number.EPSILON;
    }
    nearlyEqual(0.1 + 0.2, 0.3); // true
    ```

### Safe Integers

-   Max safe integer: `2^53 - 1` → `9007199254740991`

-   Provided as:

    -   `Number.MAX_SAFE_INTEGER`
    -   `Number.MIN_SAFE_INTEGER`

-   Use `Number.isSafeInteger(..)` to test.

### Integers in Practice

-   `Number.isInteger(42)` → true

-   `Number.isInteger(42.3)` → false

-   Some operations (like bitwise) only work with **32-bit signed integers**.

---

## 6. Special Values

### `null` & `undefined`

-   `undefined`: declared variable with no value.
-   `null`: intentional “empty” value.
-   Distinction:

    -   `undefined` → not assigned yet.
    -   `null` → was assigned but explicitly empty.

### `void` Operator

-   Always returns `undefined`.

    ```js
    void 42; // undefined
    ```

Useful for ensuring no return value:

```js
return void setTimeout(doTask, 100);
```

---

### `NaN` (Not a Number)

-   Represents invalid number results.

    ```js
    let x = 2 / "foo"; // NaN
    typeof x; // "number"
    ```

-   Special: `NaN !== NaN` → only value not equal to itself.

#### Checking

-   `isNaN("foo")` → true (buggy: checks “not a number,” not actual NaN).
-   Use **ES6**: `Number.isNaN(..)`.

    ```js
    Number.isNaN(2 / "foo"); // true
    Number.isNaN("foo"); // false
    ```

---

### `Infinity` & `-Infinity`

-   Division by zero:

    ```js
    1 / 0; // Infinity
    -1 / 0; // -Infinity
    ```

-   Defined values:
    `Number.POSITIVE_INFINITY`, `Number.NEGATIVE_INFINITY`.

---

## 7. Review

-   Arrays: dynamic, allow mixed types, but should only use numeric indices.
-   Strings: array-like but immutable. Use arrays for frequent char-level operations.
-   Numbers: floating-point, no true integers, precision issues require care.
-   Special Values:

    -   `undefined` vs `null`
    -   `NaN` (use `Number.isNaN`)
    -   `Infinity`
    -   `void` operator
