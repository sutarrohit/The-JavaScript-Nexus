# Chapter 3: Natives

## 1. What Are Natives?

-   **Natives** (aka _built-in constructors_) are global functions provided by JS:

    -   `String`, `Number`, `Boolean`
    -   `Object`, `Function`, `Array`
    -   `RegExp`, `Date`, `Error`
    -   ES6+: `Symbol`, `Map`, `Set`, `WeakMap`, `WeakSet`

-   They serve two main purposes:

    1. As **constructors** (via `new`): create object instances.
    2. As **utility functions**: expose methods for working with values.

Confusion: primitives (`"hello"`, `42`) are not objects, but they can **borrow** methods from their native object counterparts (`String`, `Number`).

---

## 2. Internal `[[Class]]`

-   Every object has an internal property `[[Class]]` that describes what kind of object it is.
-   Not directly accessible, but can be checked via:

    ```js
    Object.prototype.toString.call([1, 2, 3]); // "[object Array]"
    Object.prototype.toString.call("foo"); // "[object String]"
    Object.prototype.toString.call(null); // "[object Null]"
    Object.prototype.toString.call(undefined); // "[object Undefined]"
    ```

-   Useful to distinguish between objects more accurately than `typeof`:

    ```js
    typeof []; // "object"
    Object.prototype.toString.call([]); // "[object Array]"
    ```

---

## 3. Boxing Wrappers

-   JS allows primitives to access methods and properties:

    ```js
    "hello".toUpperCase(); // "HELLO"
    (42).toFixed(2); // "42.00"
    true.toString(); // "true"
    ```

-   How?

    -   JS temporarily wraps the primitive with an **object wrapper**:

        -   `"hello"` → `new String("hello")`
        -   `42` → `new Number(42)`
        -   `true` → `new Boolean(true)`

-   After the method call, the wrapper is discarded.
-   This process is called **boxing**.

---

## 4. Unboxing

-   **Unboxing** = converting wrapper object back into its primitive value.
-   Done using `.valueOf()`:

    ```js
    let numObj = new Number(42);
    console.log(numObj.valueOf()); // 42
    ```

-   Happens automatically when a primitive is required:

    ```js
    let n = new Number(42);
    console.log(n + 1); // 43 (unboxed)
    ```

**Gotcha** with Boolean objects:

```js
let b = new Boolean(false);
if (b) console.log("truthy!"); // runs!
```

-   Reason: `b` is an object, and all objects are truthy, even if wrapping `false`.

---

## 5. Natives as Constructors

### String

```js
let s1 = "hello"; // primitive string
let s2 = new String("hello"); // object wrapper
console.log(typeof s1); // "string"
console.log(typeof s2); // "object"
console.log(s1 === s2); // false
```

Best practice: **never use `new String`** unless you explicitly need an object.

---

### Number

```js
let n1 = 42; // primitive
let n2 = new Number(42); // object
n1 === n2; // false
```

Avoid `new Number` → can cause bugs in equality checks.

---

### Boolean

```js
let b1 = false; // primitive
let b2 = new Boolean(false); // object
if (b2) console.log("truthy"); // executes!
```

`new Boolean(false)` is **always truthy**.
Always use `true` / `false` primitives.

---

### Object

```js
let o1 = {}; // literal
let o2 = new Object(); // same result
```

Prefer `{}` — shorter and clearer.

---

### Array

```js
let a1 = [1, 2, 3]; // literal
let a2 = new Array(3); // [ <3 empty slots> ]
let a3 = new Array(1, 2, 3); // [1,2,3]
```

Ambiguity: `new Array(3)` creates empty slots.
Prefer `[]` literal syntax.

---

### Function

```js
let f1 = function (x) {
    return x * 2;
};
let f2 = new Function("x", "return x * 2;");
```

-   Both are valid, but `Function` constructor is dangerous:

    -   Similar to `eval(..)` — executes code from a string.
    -   Security & performance issues.
        Avoid `new Function(..)` unless absolutely necessary.

---

### RegExp

```js
let r1 = /foo/i;
let r2 = new RegExp("foo", "i");
```

-   Both valid.
-   Prefer literals (`/foo/`) unless you need dynamic regex from variables.

---

### Date

```js
let d = new Date();
console.log(d.toISOString());
```

-   Must be created via constructor.
-   Useful for working with timestamps and date formatting.

---

### Error

-   Built-in error constructors: `Error`, `TypeError`, `ReferenceError`, etc.

```js
throw new Error("Something went wrong");
```

-   Useful for custom error handling and debugging.

---

## 6. Wrapper Objects vs Primitive Literals

-   Primitives cannot store custom properties:

    ```js
    let s = "hello";
    s.name = "greeting";
    console.log(s.name); // undefined
    ```

-   Objects can:

    ```js
    let objStr = new String("hello");
    objStr.name = "greeting";
    console.log(objStr.name); // "greeting"
    ```

-   But storing data on wrapper objects is a bad practice → confusing, rarely useful.

---

## 7. Good vs Bad Practices

| Native   | Good               | Bad                       |
| -------- | ------------------ | ------------------------- |
| String   | `"hello"`          | `new String("hello")`     |
| Number   | `42`               | `new Number(42)`          |
| Boolean  | `true`             | `new Boolean(true)`       |
| Object   | `{}`               | `new Object()`            |
| Array    | `[1,2,3]`          | `new Array(3)`            |
| Function | `function(x){}`    | `new Function("x","...")` |
| RegExp   | `/foo/i`           | `new RegExp("foo","i")`   |
| Date     | `new Date()`       | ( correct usage)          |
| Error    | `new Error("msg")` | ( correct usage)          |

---

## 8. Review

-   **Natives** are constructors like `String`, `Number`, `Boolean`, `Array`, `Object`, `Function`, `Date`, `RegExp`, `Error`.
-   **Boxing**: primitives temporarily wrapped to access methods.
-   **Unboxing**: `.valueOf()` returns primitive.
-   **Avoid using constructors** for primitives — they create objects, not values.
-   Prefer **literals** (`"str"`, `42`, `true`, `[]`, `{}`) for clarity and reliability.
-   Use constructors only where necessary (`Date`, `Error`, `RegExp`).
-   Be extra cautious with `Boolean` objects → always truthy!
