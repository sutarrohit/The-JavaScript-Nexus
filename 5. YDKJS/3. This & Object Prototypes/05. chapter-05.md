## **Chapter 5 – Prototypes**

### 1. **The `[[Prototype]]` Internal Slot**

-   Every JavaScript object has an internal hidden property called `[[Prototype]]`.
-   This is **not** the same as the `.prototype` property found on functions.
-   `[[Prototype]]` points to another object or `null`.
-   Acts as a **fallback** mechanism:

    -   When you try to access a property on an object, JS first looks at the object itself.
    -   If it’s not found, it looks at the object’s `[[Prototype]]`.
    -   This continues up the chain until it reaches `null` (end of chain).

-   This lookup mechanism is called the **prototype chain**.

---

### 2. **`Object.prototype`**

-   By default, ordinary objects’ `[[Prototype]]` points to `Object.prototype`.
-   `Object.prototype` is at the top of the chain (unless you use `Object.create(null)`).
-   Provides common utility methods:

    -   `toString()`
    -   `valueOf()`
    -   `hasOwnProperty()`
    -   `isPrototypeOf()`

-   If an object doesn’t have a property, and it’s not found anywhere in the chain, JS returns `undefined`.

---

### 3. **Functions and the `.prototype` Property**

-   Every function, when created, automatically gets a `.prototype` property.
-   This `.prototype` property is **only used** when the function is invoked with `new`.
-   Example:

    ```js
    function Foo() {}
    Foo.prototype; // an object with a default .constructor property
    ```

-   When you do `new Foo()`, the newly created object’s `[[Prototype]]` is set to `Foo.prototype`.

---

### 4. **Constructor Calls (`new`)**

Using `new` on a function call:

1. Creates a new empty object.
2. Links that object’s `[[Prototype]]` to the constructor’s `.prototype`.
3. Binds `this` inside the constructor to the new object.
4. Executes the constructor function.
5. Returns the new object unless the constructor explicitly returns another object.

**Note:** Functions used with `new` are often called “constructor functions”, but in JS they are just regular functions called with the `new` keyword.

---

### 5. **Shadowing Properties**

-   If a property exists directly on the object, it will **shadow** any property with the same name in the prototype chain.
-   Shadowing does not remove or overwrite the property in the prototype—it simply hides it for that object.
-   Example:

    ```js
    var obj = { a: 1 };
    var proto = { a: 42 };
    Object.setPrototypeOf(obj, proto);

    obj.a; // 1 (shadowing proto.a)
    ```

---

### 6. **Checking for Own Properties**

-   `hasOwnProperty(prop)` → returns `true` only if the property exists directly on the object (not inherited).
-   `in` operator → returns `true` if the property exists anywhere in the chain.

Example:

```js
proto = { a: 42 };
obj = Object.create(proto);
obj.b = 2;

obj.hasOwnProperty("a"); // false
"a" in obj; // true
```

---

### 7. **Creating Objects with Prototypes**

-   **`Object.create(proto)`**: creates a new object and directly links it to the given `proto`.
-   Allows you to avoid constructors if you want to directly set up delegation.
-   Example:

    ```js
    var parent = {
        greet() {
            console.log("hi");
        }
    };
    var child = Object.create(parent);
    child.greet(); // 'hi'
    ```

---

### 8. **Accessing/Setting Prototypes**

-   Legacy: `obj.__proto__` (non-standard, but widely supported).
-   Standard:

    -   `Object.getPrototypeOf(obj)` → gets `[[Prototype]]`.
    -   `Object.setPrototypeOf(obj, proto)` → sets `[[Prototype]]` (slower—avoid in performance-critical code).

-   Best practice: Use `Object.create()` during creation rather than changing prototype later.

---

### 9. **Prototypal Inheritance**

-   Better called **delegation**:

    -   Objects _delegate_ property/method access to their prototypes.
    -   Avoids duplication; multiple objects can share the same method definitions.

-   Example:

    ```js
    var animal = {
        speak() {
            console.log(this.sound);
        }
    };
    var dog = Object.create(animal);
    dog.sound = "woof";
    dog.speak(); // 'woof'
    ```

---

### 10. **Behavior and Memory Benefits**

-   Shared methods live in one place (prototype) → memory efficiency.
-   Changing a method in the prototype affects all objects linked to it.
-   Prototype chains can be long, but too deep chains can impact performance.

---

If you like, I can now **extend this into a visual flow diagram** showing:

-   How `[[Prototype]]` links work
-   How property lookups happen step-by-step
    This would make the chapter’s concepts much easier to remember.
