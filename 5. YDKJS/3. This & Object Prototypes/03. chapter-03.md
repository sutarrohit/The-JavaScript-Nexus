# Chapter 3: Objects

## Syntax

-   Objects can be created in two forms:
    1. **Literal (Declarative) Form**:
        ```javascript
        var myObj = {
            key: value
        };
        ```
    2. **Constructed Form**:
        ```javascript
        var myObj = new Object();
        myObj.key = value;
        ```
-   The literal form is preferred in most cases.

## Type

-   JavaScript has 6 primary types:
    -   `string`, `number`, `boolean`, `null`, `undefined`, `object`
-   Note: `typeof null` returns `"object"` (this is a bug)
-   Complex primitives (subtypes):
    -   `function` (callable object)
    -   `array` (structured object)

## Built-in Objects

-   Built-in object subtypes (often confused with actual types):
    -   `String`, `Number`, `Boolean`, `Object`, `Function`, `Array`, `Date`, `RegExp`, `Error`
-   These are actually built-in functions that can be used as constructors:

    ```javascript
    var strPrimitive = "I'm a string"; // primitive
    typeof strPrimitive; // "string"

    var strObject = new String("I'm a string"); // object
    typeof strObject; // "object"
    ```

## Contents

-   Objects contain properties stored at named locations (keys).
-   Property access:
    -   Dot notation (`obj.a`)
    -   Bracket notation (`obj["a"]`)
-   Bracket notation allows for computed property names (ES6):
    ```javascript
    var prefix = "foo";
    var myObj = {
        [prefix + "bar"]: "hello"
    };
    myObj.foobar; // "hello"
    ```

### Property vs. Method

-   There's no real "method" in JavaScript - just functions that happen to be object properties.
-   Example:

    ```javascript
    function foo() {
        console.log("foo");
    }

    var someFoo = foo; // reference to same function
    var myObj = {
        someFoo: foo
    };

    foo; // function foo(){..}
    someFoo; // function foo(){..}
    myObj.someFoo; // function foo(){..}
    ```

### Arrays

-   Arrays are objects with numeric indexing:
    ```javascript
    var myArray = ["foo", 42, "bar"];
    myArray.length; // 3
    myArray[0]; // "foo"
    ```
-   Can add properties (but this is usually a bad idea):
    ```javascript
    myArray.baz = "baz";
    myArray.length; // 3 (unchanged)
    ```

### Duplicating Objects

-   There's no built-in way to truly duplicate an object.
-   Shallow copy vs. deep copy considerations:
    ```javascript
    var myObject = {
        a: 2,
        b: anotherObject, // reference, not copy!
        c: anotherArray, // reference
        d: anotherFunction
    };
    ```
-   JSON-safe objects can be copied with:
    ```javascript
    var newObj = JSON.parse(JSON.stringify(someObj));
    ```
-   ES6's `Object.assign()` performs shallow copy:
    ```javascript
    var newObj = Object.assign({}, myObject);
    ```

## Property Descriptors

-   As of ES5, all properties are described with a property descriptor:
    ```javascript
    Object.getOwnPropertyDescriptor(myObj, "a");
    /* Returns:
    {
      value: 2,
      writable: true,
      enumerable: true,
      configurable: true
    }
    */
    ```
-   Can define properties with specific characteristics:
    ```javascript
    Object.defineProperty(myObj, "a", {
        value: 2,
        writable: true,
        configurable: true,
        enumerable: true
    });
    ```

### Writable

-   Controls whether a property value can be changed:

    ```javascript
    Object.defineProperty(myObj, "a", {
        value: 2,
        writable: false, // not writable!
        configurable: true,
        enumerable: true
    });

    myObj.a = 3; // silently fails in non-strict mode
    myObj.a; // 2
    ```

### Configurable

-   Controls whether a property can be reconfigured or deleted:

    ```javascript
    Object.defineProperty(myObj, "a", {
        value: 2,
        writable: true,
        configurable: false, // not configurable!
        enumerable: true
    });

    myObj.a = 3; // works
    delete myObj.a; // fails silently
    myObj.a; // 3
    ```

### Enumerable

-   Controls whether a property shows up in enumerations like `for..in`:
    ```javascript
    Object.defineProperty(myObj, "a", {
        enumerable: false // won't show up in for..in
    });
    ```

## Immutability

-   ES5 provides ways to create immutable objects/properties:

1. **Object Constant**:
    ```javascript
    Object.defineProperty(myObj, "FAVORITE_NUMBER", {
        value: 42,
        writable: false,
        configurable: false
    });
    ```
2. **Prevent Extensions**:
    ```javascript
    Object.preventExtensions(myObj);
    myObj.b = 3; // silently fails (or throws in strict mode)
    ```

(Continued in next section with `Object.seal()` and `Object.freeze()`)

---

## **Immutability (Continued)**

JavaScript provides ways to make objects/properties immutable (unchangeable):

### **3. Seal**

-   **`Object.seal()`**:

    -   Prevents adding new properties
    -   Marks all existing properties as **`configurable: false`**
    -   Existing properties can still be modified (if `writable: true`)

    ```javascript
    var obj = { a: 2 };
    Object.seal(obj);

    obj.b = 3; // Fails (cannot add)
    delete obj.a; // Fails (cannot delete)
    obj.a = 3; // Works (can modify)
    ```

### **4. Freeze**

-   **`Object.freeze()`**:

    -   Does everything `Object.seal()` does
    -   Additionally marks all properties as **`writable: false`**
    -   Highest level of immutability

    ```javascript
    var obj = { a: 2 };
    Object.freeze(obj);

    obj.b = 3; // Fails (cannot add)
    delete obj.a; // Fails (cannot delete)
    obj.a = 3; // Fails (cannot modify)
    ```

⚠ **Note**:

-   These are **shallow** immutability (nested objects are not affected).
-   To deep-freeze, recursively apply `Object.freeze()` to nested objects.

---

## **Property Access Internals**

### **1. [[Get]] Operation**

When accessing a property (`obj.a`), JavaScript performs:

1. Checks if `"a"` exists directly on `obj`.
2. If not found, traverses the **prototype chain** (Ch. 5).
3. Returns `undefined` if not found anywhere.

```javascript
var obj = { a: 2 };
obj.a; // 2 ([[Get]] looks for "a")
obj.b; // undefined (not found)
```

### **2. [[Put]] Operation**

When assigning a property (`obj.a = 4`), behavior depends on:

1. **If property exists**:
    - Checks `writable` descriptor.
    - If `true`, updates the value.
    - If `false`, silently fails (or throws in strict mode).
2. **If property doesn’t exist**:
    - Checks the **prototype chain** (Ch. 5).
    - If not found, adds the property to the object.

---

## **Getters & Setters**

### **1. Accessor Descriptors**

-   Override default `[[Get]]` and `[[Put]]` behavior.
-   Defined via `get` and `set` in property descriptors.

```javascript
var obj = {
    get a() {
        return this._a_;
    }, // Custom getter
    set a(val) {
        this._a_ = val * 2;
    } // Custom setter
};

obj.a = 2; // Calls setter
obj.a; // 4 (getter returns this._a_)
```

### **2. Defining with `Object.defineProperty`**

```javascript
Object.defineProperty(obj, "b", {
    get: function () {
        return this._b_;
    },
    set: function (val) {
        this._b_ = val;
    },
    enumerable: true
});
```

---

## **Property Existence**

### **1. `in` Operator**

-   Checks if a property exists **anywhere** in the prototype chain.

```javascript
"a" in obj; // true (checks obj and prototypes)
```

### **2. `hasOwnProperty`**

-   Checks if a property exists **directly** on the object (ignores prototype chain).

```javascript
obj.hasOwnProperty("a"); // true (only checks obj)
```

⚠ **Edge Case**:

-   If an object is created with `Object.create(null)`, it won’t have `hasOwnProperty`.
-   Use:
    ```javascript
    Object.prototype.hasOwnProperty.call(obj, "a");
    ```

---

## **Enumeration**

### **1. `for..in` Loop**

-   Iterates over **enumerable** properties (including prototype chain).
-   Best used for **objects** (not arrays).

```javascript
for (var k in obj) {
    console.log(k, obj[k]); // Logs enumerable keys
}
```

### **2. `Object.keys()` vs. `Object.getOwnPropertyNames()`**

| Method                            | Description                           | Includes Non-Enumerable? |
| --------------------------------- | ------------------------------------- | ------------------------ |
| `Object.keys(obj)`                | Returns **enumerable** own properties | ❌ No                    |
| `Object.getOwnPropertyNames(obj)` | Returns **all** own properties        | ✅ Yes                   |

```javascript
Object.keys(obj); // ["a"] (only enumerable)
Object.getOwnPropertyNames(obj); // ["a", "b"] (all)
```

---

## **Iteration (ES6+)**

### **1. `for..of` Loop**

-   Iterates over **values** (not keys) in iterables (arrays, strings, etc.).
-   Uses the **`@@iterator`** protocol.

```javascript
var arr = [1, 2, 3];
for (var v of arr) {
    console.log(v); // 1, 2, 3
}
```

### **2. Custom Iterators**

-   Define `Symbol.iterator` to make objects iterable.

```javascript
var obj = {
    a: 1,
    b: 2,
    [Symbol.iterator]: function () {
        var keys = Object.keys(this);
        var idx = 0;
        return {
            next: () => ({
                value: this[keys[idx++]],
                done: idx > keys.length
            })
        };
    }
};

for (var v of obj) {
    console.log(v); // 1, 2
}
```

---

## **Summary (Key Takeaways)**

1. **Immutability**

    - `Object.preventExtensions()` → No new props
    - `Object.seal()` → No new props + `configurable: false`
    - `Object.freeze()` → No changes at all

2. **Property Access**

    - `[[Get]]` → Looks up the prototype chain
    - `[[Put]]` → Depends on `writable` and prototypes

3. **Getters/Setters**

    - Override default property access behavior

4. **Existence Checks**

    - `in` → Checks prototype chain
    - `hasOwnProperty` → Checks only own props

5. **Enumeration**

    - `for..in` → Iterates enumerable props (including prototypes)
    - `Object.keys()` → Only own enumerable props

6. **Iteration (ES6)**
    - `for..of` → Works with iterables (arrays, custom objects)
    - `Symbol.iterator` → Define custom iteration logic
