## Chapter 2: _this_ All Makes Sense Now!

This chapter dives deep into the **`this` keyword** in JavaScript, demystifying it through the **four binding rules** that govern its behavior. To understand `this`, you must begin by identifying the **call-site**—the location where a function is actually invoked.

### What is a Call-Site?

The **call-site** is **where a function is called**, _not where it’s defined_. The value of `this` is determined **at runtime**, based entirely on the function’s call-site. To figure it out, inspect the **call stack**, which tracks the series of function calls that led to the current execution point.

#### Example: Call Stack & Call-Site

```js
function baz() {
    console.log("baz");
    bar(); // Call-site for bar
}

function bar() {
    console.log("bar");
    foo(); // Call-site for foo
}

function foo() {
    console.log("foo");
}

baz(); // Call-site for baz
```

Here’s how the call-stack evolves:

-   `baz()` is called from the global scope.
-   Inside `baz`, `bar()` is called.
-   Inside `bar`, `foo()` is called.

The `this` binding depends on **how** the function is called at each step.

---

## The Four Rules of `this` Binding

When inspecting the call-site, determine which of these four rules applies. They are listed here in **order of precedence**:

### 1️. **new Binding** (Constructor Call)

When a function is called using the `new` keyword:

1. A new object is created.
2. That object is `[[Prototype]]`-linked to the function’s prototype.
3. The new object is bound as `this`.
4. The function returns the object unless it returns another one explicitly.

#### Example:

```js
function Foo(a) {
    this.a = a;
}

const bar = new Foo(2);
console.log(bar.a); // 2
```

### 2. **Explicit Binding** (`call`, `apply`, `bind`)

You can **explicitly set** `this` using:

-   `call()` and `apply()` – invoke the function immediately.
-   `bind()` – returns a new function with a fixed `this`.

#### Example with `call()`:

```js
function foo() {
    console.log(this.a);
}

const obj = { a: 2 };
foo.call(obj); // 2
```

#### Example with `bind()` (Hard Binding):

```js
const bar = foo.bind(obj);
bar(); // 2
setTimeout(bar, 100); // Still 2 – `this` is preserved.
```

### 3. **Implicit Binding** (Context Object)

If a function is called as a **method of an object**, `this` is that object.

Only the **last object in the chain** matters:

```js
obj1.obj2.foo(); // `this` is `obj2`
```

#### Example:

```js
function foo() {
    console.log(this.a);
}

const obj = {
    a: 2,
    foo: foo
};

obj.foo(); // 2
```

#### Implicitly Lost `this`

If you pass a method around without its object, the implicit binding is lost:

```js
const bar = obj.foo;
const a = "oops, global";
bar(); // "oops, global" – falls back to default binding
```

### 4. **Default Binding**

Used when none of the above rules apply—i.e., a **plain function call**.

-   In **non-strict mode**, `this` defaults to the **global object** (`window` in browsers).
-   In **strict mode**, `this` is **`undefined`**.

#### Example (Non-Strict Mode):

```js
function foo() {
    console.log(this.a);
}
const a = 2;
foo(); // 2 (global)
```

#### Example (Strict Mode):

```js
function foo() {
    "use strict";
    console.log(this.a);
}
const a = 2;
foo(); // TypeError: Cannot read property 'a' of undefined
```

## Rule Precedence Summary

If multiple rules could apply, the order of precedence is:

1. `new` Binding
2. Explicit Binding (`call`, `apply`, `bind`)
3. Implicit Binding (object context)
4. Default Binding (global or undefined)

---

## Lexical `this` (Arrow Functions)

ES6 introduced **arrow functions**, which differ from traditional function expressions:

-   Arrow functions **don’t have their own `this`**.
-   They **inherit `this` from their lexical scope**.
-   Their `this` **cannot be overridden** using `call`, `apply`, `bind`, or `new`.

This solves many issues in callback-heavy code.

#### Example:

```js
function foo() {
    return (a) => {
        console.log(this.a);
    };
}

const obj1 = { a: 2 };
const obj2 = { a: 3 };

const bar = foo.call(obj1);
bar.call(obj2); // 2 – arrow function uses `obj1`'s `this`
```

Arrow functions are essentially a cleaner alternative to:

```js
var self = this;
```

---

### Conclusion

Understanding `this` is all about understanding **how** a function is invoked. If you can identify the **call-site**, you can determine which rule applies—and from there, what `this` actually refers to.

Keep this mental checklist handy:

> **Was the function called with `new`? `call`/`apply`/`bind`? As a method? Or just directly?**

That’s how _this_ finally makes sense.
