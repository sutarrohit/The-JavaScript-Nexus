## **Chapter 4 – Async Flow Control**

### 1. Introduction

-   JavaScript requires **asynchronous programming** for tasks like network requests, file I/O, timers, etc.
-   Traditionally, **callbacks** have been the main mechanism.
-   ES6 introduces **Promises**, solving many of the problems with callbacks.
-   Combining **Promises + Generators** leads to a major improvement in async flow control.

---

### 2. **Promises**

-   **Definition**: A Promise is a **trustable intermediary** between calling code and async code.
-   Can be seen as:

    -   A **one-time event listener** (fires once, then done).
    -   A **future value** container that will eventually resolve.
    -   The **async version of a return value**.

#### States of a Promise

-   **Pending** → waiting for result.
-   **Fulfilled** → resolved successfully with a _value_.
-   **Rejected** → resolved with a _reason_ (error).
-   Once resolved (fulfilled or rejected), it is **immutable**.

#### Benefits over callbacks

-   Provide **order, predictability, and trustability**.
-   Avoids “callback hell” by sequencing logic.

---

### 3. **Making and Using Promises**

```js
var p = new Promise(function (resolve, reject) {
    // async work
});
```

-   **resolve(value)** → fulfill with value.
-   **reject(reason)** → reject with error reason.
-   **resolve(anotherPromise)** → adopts state of another promise.

#### Example: Refactoring callbacks

```js
function ajax(url) {
    return new Promise(function (resolve, reject) {
        // perform request, then resolve or reject
    });
}

ajax("http://some.url").then(
    function success(contents) {
        console.log(contents);
    },
    function error(reason) {
        console.error(reason);
    }
);
```

---

### 4. **Promise API**

-   **then(onFulfilled, onRejected)** → register handlers.
-   **catch(onRejected)** → shorthand for `.then(null, onRejected)`.
-   Both `.then` and `.catch` **return a new promise**, enabling **chaining**.

#### Chaining Example

```js
ajax("url1")
    .then((data) => ajax("url2?v=" + data))
    .then((final) => console.log(final))
    .catch((err) => console.error("Error:", err));
```

-   If a handler returns a **value** → next promise is fulfilled with it.
-   If it returns a **promise** → next promise adopts that state.
-   If it **throws an error** → next promise rejects.

#### Aggregation Utilities

-   **Promise.all(\[ .. ])** → waits for all to fulfill, rejects if any fail. (like a _gate_).
-   **Promise.race(\[ .. ])** → settles as soon as one fulfills/rejects. (like a _latch_).

⚠️ Note: `Promise.all([])` fulfills immediately, `Promise.race([])` hangs forever.

---

### 5. **Thenables**

-   Any object with a `.then(..)` method is a **thenable**.
-   Promises adopt the state of a thenable if passed to `resolve(..)`.
-   ⚠️ Not all thenables are reliable (may misbehave, e.g., calling handlers multiple times).

---

### 6. **Generators + Promises**

-   Generators (`function*`) let functions **pause and resume**.
-   When combined with promises:

    -   A generator can `yield` a promise.
    -   A runner utility resumes the generator when the promise settles.

-   This creates **synchronous-looking async code**.

#### Example

```js
function* main() {
    var data = yield ajax("url1");
    try {
        data = yield process(data);
    } catch (err) {
        data = yield handleError(err);
    }
    yield finalStep(data);
}
```

-   Looks synchronous but is async.
-   `try..catch` works across async boundaries.
-   Cleaner than deeply nested `.then` chains.

---

### 7. **Runner Utility**

To make the generator work, you need a small runner:

```js
function run(gen) {
    var it = gen();

    function handleNext(value) {
        var next = it.next(value);
        return handleResult(next);
    }

    function handleResult(next) {
        if (next.done) return next.value;
        return Promise.resolve(next.value).then(handleNext, (err) => handleResult(it.throw(err)));
    }

    return Promise.resolve().then(handleNext);
}
```

-   This utility:

    -   Starts the generator.
    -   Waits for `yield`ed promises.
    -   Resumes with resolved value or throws error for rejection.

Usage:

```js
run(main).then(
    () => console.log("Completed!"),
    (err) => console.error("Failed:", err)
);
```

---

### 8. **Why Promises + Generators?**

-   Promises alone → trustable async values but verbose chaining.
-   Generators alone → pause/resume but lack async orchestration.
-   Combined → best of both:

    -   Clean syntax.
    -   Synchronous-style async flow.
    -   Reliable error handling.
    -   Built-in concurrency with `Promise.all`.

---

### 9. **Review**

-   Callbacks are insufficient for complex async tasks.
-   **Promises** solve trust and composability issues.
-   **Generators** add synchronous-looking async flow control.
-   Together, they eliminate “callback hell”.
-   This pattern is so powerful that **ES2017 introduced `async/await`**, which is syntactic sugar over Promises + Generators .

---

✅ **Key Takeaways**

-   Always observe rejections (`.catch`).
-   Use `Promise.all` for parallel async tasks.
-   Prefer generator + promise runners (or modern `async/await`) for cleaner async flow.
-   Promises + Generators was the **bridge** to `async/await`.
