## Chapter 03 – Organization

This chapter introduces new ES6 features that improve how we **organize code**: **Iterators, Generators, Modules, and Classes**.

### 1. Iterators

-   **Definition:** A structured way to pull values from a source one at a time.
-   Common before ES6, but ES6 provides a **standardized interface**.
-   Built-in structures like Arrays, Strings, Maps, and Sets now implement this interface.

#### Iterator Interfaces

-   **Iterator (required):**

    -   `next()` → returns `{ value, done }`

-   **Iterator (optional):**

    -   `return()` → stops iteration early
    -   `throw()` → signals error inside iteration

-   **Iterable:** an object that has `@@iterator` (`Symbol.iterator`) method returning an iterator.

#### Example

```js
let arr = [1, 2, 3];
let it = arr[Symbol.iterator]();

it.next(); // { value: 1, done: false }
it.next(); // { value: 2, done: false }
it.next(); // { value: 3, done: false }
it.next(); // { value: undefined, done: true }
```

-   Strings are also iterable.
-   Maps, Sets, and custom objects can define `Symbol.iterator`.

#### Custom Iterators

-   Example: Fibonacci sequence iterator.
-   Example: A `tasks` object whose iterator executes queued functions step by step.
-   Even numbers can be made iterable (`for (let i of 3) {}` → `0 1 2 3`).

#### Iterator Consumption

-   Iterators can be consumed by:

    -   `for..of`
    -   Spread (`...`)
    -   Destructuring
    -   New ES6 collection APIs

---

### 2. Generators

-   **Special functions** with the ability to:

    -   Pause (`yield`)
    -   Resume (`next`)
    -   Allow **two-way message passing** between function and caller.

-   Declared with `function*`.

#### Example

```js
function* foo() {
    yield 1;
    yield 2;
    yield 3;
}
let it = foo();
it.next(); // {value:1, done:false}
```

#### Key Features

-   `yield` → pauses execution, returns a value.
-   `next(val)` → resumes, passes a value back in.
-   `yield*` → delegates to another generator.
-   **Iterator Control:** generators produce iterators, which drive execution.
-   **Early Completion:** `return()` and `throw()` abort generators.
-   **Error Handling:** `try..catch` works both ways, errors can propagate in/out.

#### Uses

1. **Produce values** (like custom sequences, database row iteration).
2. **Task queues / flow control** (step-by-step algorithms, async orchestration).
3. Under the hood: **generators are just state machines**.

---

### 3. Modules

-   **Most important organizational tool in JS.**

#### Before ES6

-   Relied on function closures + patterns like:

    -   IIFE (Immediately Invoked Function Expression)
    -   AMD (Asynchronous Module Definition)
    -   UMD (Universal Module Definition)

#### ES6 Modules

-   **File-based**: one module per file.

-   **Static API**: exports are fixed at compile time.

-   **Singletons**: each import gets the same instance.

-   **Import/Export Syntax:**

    ```js
    // lib.js
    export function greet(name) {
        console.log(`Hello ${name}`);
    }

    // main.js
    import { greet } from "./lib.js";
    greet("Kyle");
    ```

-   Can use:

    -   **Named exports**
    -   **Default export**
    -   **Renaming (`as`)**
    -   **Wildcard imports (`* as`)**

-   ES6 modules resolve **circular dependencies** safely.

---

### 4. Classes

-   ES6 introduces `class` as **syntactic sugar** over prototypes.

#### Features

-   **Basic Declaration**

    ```js
    class Person {
        constructor(name) {
            this.name = name;
        }
        greet() {
            console.log(`Hi, I’m ${this.name}`);
        }
    }
    ```

-   **Inheritance**

    ```js
    class Student extends Person {
        constructor(name, id) {
            super(name);
            this.id = id;
        }
    }
    ```

-   `super` keyword → refers to parent class methods/constructor.
-   `new.target` → meta property to check if function/class was called with `new`.
-   **Static methods/properties** belong to the class itself, not instances.
-   **Symbol.species** → allows customizing which constructor is used for derived class instances.

---

### 5. Review (Key Takeaways)

-   **Iterators** → Sequential consumption of data/steps. Standardized via `next()`, `return()`, `throw()`.
-   **Generators** → Functions with pause/resume. Enable state machines, task queues, async flow.
-   **Modules** → First-class syntax for modular code. File-based, singleton, statically resolved.
-   **Classes** → Cleaner syntax for prototypes, supports `extends`, `super`, `new.target`, static methods, and `Symbol.species`.
