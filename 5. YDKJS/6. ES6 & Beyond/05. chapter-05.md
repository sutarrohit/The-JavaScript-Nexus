# Chapter 5: Collections

## 1. Introduction

-   Collections are structured ways to store and access data.
-   Before ES6: main tools were **arrays** and **objects**.
-   ES6 introduced new **native data structures**:

    -   **Typed Arrays** (binary data views)
    -   **Maps** (key-value pairs with any type as key)
    -   **Sets** (unique collections of values)
    -   **WeakMaps** & **WeakSets** (memory-sensitive versions).

---

## 2. Typed Arrays

### Purpose:

-   Provide array-like access to **binary data**.
-   Useful for **video, audio, canvas data, network protocols, cryptography**.

### Key Components:

-   **ArrayBuffer**: fixed-length raw binary buffer.

    ```js
    var buf = new ArrayBuffer(32); // 32 bytes (256 bits)
    buf.byteLength; // 32
    ```

-   **Views**: Typed arrays overlay on buffers to interpret bits:

    -   Int8Array, Uint8Array, Uint8ClampedArray
    -   Int16Array, Uint16Array
    -   Int32Array, Uint32Array
    -   Float32Array, Float64Array

    ```js
    var arr = new Uint16Array(buf);
    arr.length; // 16 (since 32 bytes / 2 bytes per element)
    ```

### Important Concepts:

-   **Endianness**: order of bytes in multi-byte numbers.

    -   Little-endian (most common) vs Big-endian.
    -   Must align producer & consumer systems.

-   **Multiple Views**: same buffer can be read differently.

    ```js
    var buf = new ArrayBuffer(2);
    var view8 = new Uint8Array(buf);
    var view16 = new Uint16Array(buf);
    view16[0] = 3085;
    console.log(view8); // shows split bytes
    ```

-   **Typed Array Constructors**:

    -   `new Type(length)` → fresh buffer
    -   `new Type(buffer, offset, length)` → view on existing buffer
    -   `new Type(typedArray)` → copy existing
    -   `new Type(obj)` → from iterable/array-like.

---

## 3. Maps

### Purpose:

-   Store **key/value pairs** where keys can be **any type** (not just strings).
-   Fixes limitation of objects (`{}` only allows string/symbol keys).

### Example:

```js
var m = new Map();
var x = { id: 1 },
    y = { id: 2 };
m.set(x, "foo");
m.set(y, "bar");
m.get(x); // "foo"
```

### Features:

-   `set(key, value)`, `get(key)`, `delete(key)`, `clear()`.
-   `size` property (instead of `length`).
-   Iterators:

    -   `keys()`, `values()`, `entries()`.
    -   Default iterator = `entries()`.

-   Accepts an **iterable of [key, value] pairs** in constructor.
-   Use when keys need to be **objects**.

---

## 4. WeakMaps

### Differences from Map:

-   Keys must be **objects**.
-   Keys are **weakly held** (GC can remove them if no other references).
-   API: `set`, `get`, `has`, `delete`.
-   **No size property, no clear(), no iterators** → non-enumerable.
-   Use case: attach metadata to objects (e.g., DOM elements) without preventing GC.

---

## 5. Sets

### Purpose:

-   Store **unique values** (duplicates ignored).
-   Any type of value allowed.

### Example:

```js
var s = new Set();
s.add(1).add(2).add(2);
s.size; // 2
```

### Features:

-   `add(value)`, `delete(value)`, `clear()`.
-   `has(value)` for existence check.
-   Iterators:

    -   `keys()`, `values()` → same result.
    -   `entries()` → [value, value].
    -   Default iterator = `values()`.

-   Useful for **deduplicating arrays**:

    ```js
    var uniques = [...new Set([1, 2, 3, 4, "1", 2, 4, "5"])];
    // [1,2,3,4,"1","5"]
    ```

---

## 6. WeakSets

### Purpose:

-   Like Sets, but hold **object values weakly**.
-   GC can remove entries when object references are gone.
-   API: `add`, `has`, `delete`.
-   Restrictions:

    -   Only objects allowed (no primitives).
    -   No `size`, no iteration.

-   Useful for **tracking objects without preventing collection**.

---

## 7. Review

-   **Typed Arrays**: Efficient binary data manipulation.
-   **Maps**: Key/value with object keys allowed.
-   **Sets**: Unique collections.
-   **WeakMaps/WeakSets**: GC-friendly, non-enumerable.

---
