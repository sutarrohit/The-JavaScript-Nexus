## Chapter 02 – Syntax

### 1. Block-Scoped Declarations

-   Traditionally, JavaScript used **function scope** via `var`.
-   ES6 introduces **block scoping** using `let` and `const`.
-   `{ .. }` creates a new scope when using `let`/`const`.
-   **Best practice:** declare `let` variables at the top of the block to avoid TDZ issues.
-   **Temporal Dead Zone (TDZ):** Accessing a variable before it’s declared with `let`/`const` causes a runtime error.
-   `typeof` behaves differently: accessing a TDZ variable causes an error instead of returning `"undefined"`.
-   **for loops with let:** each iteration gets a fresh variable binding (solves closure issues with `var`).

---

### 2. `const` Declarations

-   Like `let`, but variables are **read-only after initialization**.
-   Must be initialized at declaration.
-   Applies only to the **binding**, not the value.
    Example:

    ```js
    const arr = [1, 2, 3];
    arr.push(4); // allowed
    arr = [5, 6]; // TypeError
    ```

-   Useful for signaling intent that a variable should not be reassigned.

---

### 3. Spread / Rest Operator (`...`)

-   **Spread:** expands arrays/iterables into individual elements.

    ```js
    foo(...[1, 2, 3]); // same as foo(1,2,3)
    ```

-   **Rest (Gather):** collects multiple values into an array.

    ```js
    function bar(x, ...rest) {
        console.log(rest);
    }
    bar(1, 2, 3); // [2,3]
    ```

-   Replaces many `apply(..)` and `arguments` hacks from ES5.

---

### 4. Default Parameter Values

-   Old pattern:

    ```js
    function foo(x) {
        x = x || 10;
    }
    ```

    Problem: `0` or `""` gets replaced since they’re falsy.

-   ES6 solution:

    ```js
    function foo(x = 10, y = 20) {
        console.log(x, y);
    }
    ```

-   `undefined` triggers default values, but `null` is treated as `0` (coerced).

#### Default Value Expressions

-   Defaults can be computed expressions or function calls.
-   Lazily evaluated (only when needed).
-   Parameter scope is separate and can cause **TDZ errors** if referencing other parameters incorrectly.

---

### 5. Destructuring

-   **Array destructuring:**

    ```js
    let [a, b] = [1, 2]; // a=1, b=2
    ```

-   **Object destructuring:**

    ```js
    let { x, y } = { x: 10, y: 20 }; // x=10, y=20
    ```

-   **Property renaming:**

    ```js
    let { x: foo } = { x: 10 }; // foo=10
    ```

-   **Defaults:**

    ```js
    let [a = 5] = []; // a=5
    let { x = 3 } = {}; // x=3
    ```

-   Can be used in **assignments**, not only declarations.

#### Nested Destructuring

-   Works with deeply nested objects/arrays.
-   Example:

    ```js
    let {
        p: { q }
    } = { p: { q: 42 } }; // q=42
    ```

#### Destructuring in Parameters

-   Enables **named parameters** style.

    ```js
    function foo({ x = 1, y = 2 }) {
        console.log(x, y);
    }
    foo({ y: 10 }); // 1, 10
    ```

-   Works with arrays, objects, defaults, and rest parameters.

---

### 6. Object Literal Extensions

-   **Shorthand properties:**

    ```js
    let a = 1,
        b = 2;
    let obj = { a, b }; // {a:1, b:2}
    ```

-   **Shorthand methods:**

    ```js
    let obj = {
        foo() {
            return 42;
        }
    };
    ```

-   **Computed property names:**

    ```js
    let prop = "name";
    let obj = { [prop]: "Kyle" }; // {name: "Kyle"}
    ```

-   **Set prototype in literals:**

    ```js
    let obj = { __proto__: someProto };
    ```

-   **super keyword:** allows method delegation in object literals.

---

### 7. Template Literals

-   Use backticks (\`).
-   **Multiline strings**:

    ```js
    let str = `Hello
    World`;
    ```

-   **Interpolation:**

    ```js
    let name = "Kyle";
    console.log(`Hello, ${name}`);
    ```

-   **Tagged templates:** allow preprocessing/interpreting templates.

---

### 8. Arrow Functions

-   Shorter syntax for functions.
-   Do not bind their own `this`, `arguments`, or `super`.
-   Inherit `this` from surrounding scope (**lexical this**).
-   Cannot be used as constructors.

---

### 9. for..of Loops

-   Iterates over iterable values (arrays, strings, maps, etc.).
-   Example:

    ```js
    for (let v of [1, 2, 3]) console.log(v);
    ```

---

### 10. Regular Expression Improvements

-   **Flags:**

    -   `u` (Unicode-aware matching).
    -   `y` (sticky flag: matches from current index).

-   `flags` property now available on RegExp objects.

---

### 11. Number & String Enhancements

-   **Binary/Octal literals:**

    ```js
    0b1010 === 10;
    0o12 === 10;
    ```

-   **Unicode string support:**

    -   Full Unicode escapes (`\u{1F600}`).
    -   `codePointAt`, `fromCodePoint` methods.
    -   `includes`, `startsWith`, `endsWith`, `repeat`.

---

### 12. Symbols

-   New primitive type: `Symbol()`.
-   Unique, immutable identifiers.
-   Useful as object property keys to avoid name collisions.
-   **Symbol registry:** `Symbol.for` and `Symbol.keyFor`.
-   Built-in well-known symbols like `Symbol.iterator`.
