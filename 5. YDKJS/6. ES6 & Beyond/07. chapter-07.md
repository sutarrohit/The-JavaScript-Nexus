# Chapter 7: Meta Programming

Meta programming is about writing code that manipulates or inspects itself or its runtime environment. ES6 greatly expands JavaScript’s meta programming abilities.

## 1. Function Names

-   Functions now automatically infer a `name` property:

    ```js
    var f = function () {};
    f.name; // "f"
    ```

-   Methods in object literals and class declarations also have names inferred.
-   `name` is **non-writable but configurable** (can be changed with `Object.defineProperty`).

---

## 2. Meta Properties

-   Special properties that give metadata about runtime behavior.
-   Example: **`new.target`**

    -   Inside constructors, `new.target` refers to the constructor that was directly invoked.
    -   Helps differentiate between direct instantiation and subclassing.

    ```js
    class Parent {
        constructor() {
            if (new.target === Parent) console.log("Parent created");
            else console.log("Child created");
        }
    }
    class Child extends Parent {}
    new Parent(); // "Parent created"
    new Child(); // "Child created"
    ```

---

## 3. Well-Known Symbols (WKS)

Symbols that customize intrinsic behaviors.

### a. `Symbol.iterator`

-   Defines default iteration behavior (used in `for..of`, spread, etc.).

### b. `Symbol.toStringTag`

-   Controls `[object ___]` stringification.

    ```js
    obj[Symbol.toStringTag] = "Custom";
    Object.prototype.toString.call(obj); // [object Custom]
    ```

### c. `Symbol.hasInstance`

-   Customizes `instanceof` checks.

### d. `Symbol.species`

-   Controls which constructor is used when derived classes spawn new instances (e.g., `slice` on arrays).

### e. `Symbol.toPrimitive`

-   Customizes object → primitive coercion.

    ```js
    obj[Symbol.toPrimitive] = function (hint) {
        return hint === "number" ? 42 : "hello";
    };
    +obj; // 42
    String(obj); // "hello"
    ```

### f. Regex Symbols (`Symbol.match`, `Symbol.replace`, etc.)

-   Control how regex objects behave with string methods.

### g. `Symbol.isConcatSpreadable`

-   Decides if an object should be flattened during `Array.prototype.concat`.

### h. `Symbol.unscopables`

-   Prevents certain properties from showing up in `with` statements (deprecated feature).

---

## 4. Proxies

-   Proxies wrap objects and intercept operations via **traps**.
-   Example:

    ```js
    var target = { a: 1 };
    var proxy = new Proxy(target, {
        get(target, key) {
            console.log("Accessing:", key);
            return target[key];
        }
    });
    proxy.a; // logs "Accessing: a", then returns 1
    ```

-   Common traps: `get`, `set`, `has`, `deleteProperty`, `apply`, `construct`.
-   Can create **revocable proxies** (`Proxy.revocable`) which can be disabled.
-   Limitations: Some built-ins and internal operations are not proxyable.

---

## 5. Reflect API

-   Mirror object that provides utility methods corresponding to proxy traps.
-   Safer than `Object.*` methods (throws instead of coercing).
-   Examples:

    ```js
    Reflect.get(obj, "key");
    Reflect.set(obj, "key", value);
    Reflect.apply(fn, thisArg, args);
    Reflect.construct(Fn, args);
    Reflect.ownKeys(obj); // all keys (string + symbols)
    ```

-   Often used together with Proxies for forwarding operations.

---

## 6. Feature Testing

-   ES6 encourages **runtime feature detection** (instead of UA sniffing).
-   Example: Check if `Symbol.iterator` is supported:

    ```js
    if (typeof Symbol !== "undefined" && Symbol.iterator) { ... }
    ```

---

## 7. Tail Call Optimization (TCO)

-   Tail calls reuse the current stack frame, preventing stack overflows.
-   Only works in **strict mode** and for **proper tail calls** (nothing left to do after the call).
-   Example:

    ```js
    "use strict";
    function factorial(n, acc = 1) {
        if (n <= 1) return acc;
        return factorial(n - 1, n * acc); // proper tail call
    }
    factorial(100000); // Works with TCO
    ```

-   If not written in tail position, TCO won’t apply.
-   Alternatives in non-TCO engines: trampolining, manual loop rewriting.

---

## 8. Review / Takeaways

-   **Meta programming lets you bend the language**:

    -   Inspect execution with `new.target`.
    -   Customize core behaviors with well-known symbols.
    -   Intercept operations with Proxies.
    -   Use Reflect for precise meta operations.
    -   Detect features at runtime.
    -   Write recursion-friendly code with TCO.
