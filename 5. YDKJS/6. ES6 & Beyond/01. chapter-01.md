# Chapter 1 – ES Now & Future

This chapter sets the stage for understanding ES6 (ECMAScript 2015) and beyond. It introduces the background, versioning, and strategies developers must use to adapt to the evolving JavaScript language.

## 1. Background

-   Assumes readers already know **JavaScript up to ES5 (ES 5.1)**.
-   ES6 is a **major jump forward** compared to ES5:

    -   Not just new APIs, but many **new syntactic forms**.
    -   Includes **new organizational structures** and **helper APIs**.

-   The chapter encourages developers to **adopt ES6+ features early** instead of waiting years (as many did with ES5).

---

## 2. Versioning

### ECMAScript (ES)

-   Official name of the JavaScript standard.
-   Previously versioned by numbers: **ES1, ES2, ES3, ES5**.

    -   **ES3**: first widely used baseline (IE6-8, Android 2.x).
    -   **ES4**: abandoned due to political conflicts.
    -   **ES5 (2009)** and **ES5.1 (2011)**: became the standard during the rise of modern browsers.

### ES6 and Beyond

-   Initially referred to as **ES6**.
-   Late in development, the committee proposed **year-based naming**:

    -   e.g., **ES2015 (aka ES6)**, **ES2016 (aka ES7)**.

-   Debate: should versioning be **per-year** or **per-feature**?

    -   Modern view: JavaScript is a **living, evergreen standard**.
    -   Developers should think in **features**, not version numbers.

**Key Idea:**
Instead of saying “my code is ES6-based,” think in terms of **which features are supported** in your environment.

---

## 3. Transpiling

### The Problem

-   Developers want to use new features, but must support older browsers.
-   Historically (with ES5), adoption lagged **5+ years** because teams waited until old browsers died out.

### The Solution

-   **Transpiling** (transformation + compiling).
-   Tools (e.g., Babel, Traceur) convert ES6+ code into **ES5-compatible code**.

Example:

**ES6 shorthand property:**

```js
var foo = [1, 2, 3];
var obj = { foo }; // shorthand for foo: foo
```

**Transpiled ES5 equivalent:**

```js
var foo = [1, 2, 3];
var obj = { foo: foo };
```

-   Transpilers allow **early adoption** of new features without breaking old browsers.
-   Should be integrated into build processes (like minification, linting).

---

## 4. Shims/Polyfills

-   **Not all features need transpiling.**
-   **Polyfills (aka shims):** Implement new APIs in older environments using JS.

Example: `Object.is(..)`

```js
if (!Object.is) {
    Object.is = function (v1, v2) {
        // handle -0
        if (v1 === 0 && v2 === 0) return 1 / v1 === 1 / v2;
        // handle NaN
        if (v1 !== v1) return v2 !== v2;
        // fallback
        return v1 === v2;
    };
}
```

-   Important: polyfills **should not overwrite existing implementations**.
-   Great resource: [ES6 Shim](https://github.com/paulmillr/es6-shim/).

**Limitations:**

-   Syntax (e.g., arrow functions, `class`) **cannot** be polyfilled — needs transpilers.
-   APIs (e.g., `Object.is`, `Array.from`) often **can** be polyfilled.

---

## 5. Review / Takeaways

-   **ES6 is big**: new syntax, APIs, and programming paradigms.
-   **Version numbers matter less** — JavaScript is evolving as a **living standard**.
-   Developers should:

    -   Use **transpilers** to adopt syntax features now.
    -   Use **polyfills** for new APIs.
    -   Stop waiting for all browsers to catch up.

-   The **new mindset**: move from the **trailing edge** to the **leading edge** of JavaScript evolution.

---

## **In summary**:

Chapter 1 emphasizes **embracing ES6 early**, understanding the **shift in versioning**, and relying on **transpilers + polyfills** to keep up with JavaScript’s rapid evolution. The key lesson: **future-proof your skills and code by adopting features as they stabilize, not years later.**
