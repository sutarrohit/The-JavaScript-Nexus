## Is JavaScript Interpreted or Compiled?

Modern JavaScript is not strictly one or the other; it uses a hybrid approach called **Just-In-Time (JIT) compilation** for optimal performance. While it feels interpreted because it's executed on the fly, a compilation step happens behind the scenes.

### How Modern JavaScript Engines (e.g., V8) Work

1.  **Parsing:** The engine first reads the JavaScript source code and converts it into a data structure called an **Abstract Syntax Tree (AST)**. This tree represents the code's grammatical structure.

2.  **Interpretation:** The AST is then passed to an **interpreter** (like V8's _Ignition_). The interpreter quickly converts the AST into **bytecode**‚Äîa low-level, machine-like set of instructions. This bytecode is then executed. This allows the code to start running almost immediately.

3.  **JIT Compilation:** While the interpreter runs the bytecode, a profiler monitors the code for functions that are executed frequently (known as **"hot" functions**). These hot functions are passed to an **optimizing compiler** (like V8's _TurboFan_). TurboFan compiles them directly into highly optimized **machine code** that can be executed much faster by the computer's processor.

This process provides the best of both worlds: the fast startup time of an interpreter and the high performance of a compiled language for frequently used code.

#### Execution Flow Summary

```
JavaScript Source Code
        ‚Üì
      Parser
        ‚Üì
Abstract Syntax Tree (AST)
        ‚Üì
Interpreter (Ignition) ‚Üí Bytecode (executed quickly)
        ‚Üì
Profiler identifies "hot" code
        ‚Üì
JIT Compiler (TurboFan) ‚Üí Optimized Machine Code (runs very fast)
```

---

## üìù Chapter 1: What is Scope?

### 1\. The Core Concept of Scope

**Scope** is the set of rules that governs how the JavaScript engine looks up variables by their identifier name. In simple terms, it defines the accessibility of variables‚Äîwhere in your program you can use a variable and where you can't.

Its primary purpose is to manage variable access and prevent naming conflicts, ensuring that a variable in one part of a program doesn't accidentally modify a variable with the same name in another part.

### 2\. LHS and RHS: The Two Types of Lookups

When the engine processes your code, it performs two distinct types of lookups for variables. Understanding the difference is crucial.

-   **LHS (Left-Hand Side) Lookup:** An LHS lookup happens when a variable is the **target of an assignment**. The goal is to find the variable's container to put a value into it.

    -   Example: `message = "Hello";` // LHS lookup for `message`.

-   **RHS (Right-Hand Side) Lookup:** An RHS lookup happens when you need to **retrieve the value** of a variable.

    -   Example: `console.log(message);` // RHS lookup for `message`.

This distinction matters because the engine behaves differently if a variable isn't found.

### 3\. Nested Scope and the Scope Chain

Scopes can be layered inside one another. For example, a function declared inside another function creates a nested scope.

When the engine needs to find a variable, it follows a process called the **scope chain**:

1.  It starts the lookup in the current, innermost scope.
2.  If the variable is not found, it moves one level up to the parent scope.
3.  It repeats this process until the variable is found or until it reaches the outermost, **global scope**.

<!-- end list -->

```javascript
// Global Scope
var name = "Global";

function outer() {
    // Outer Scope
    var name = "Outer"; // This "shadows" the global 'name'

    function inner() {
        // Inner Scope
        console.log(name); // RHS lookup for 'name'
    }

    inner(); // The engine finds 'name' in the Outer Scope and prints "Outer"
}
```

### 4\. Scope-Related Errors

-   **`ReferenceError`:** This error occurs when the engine cannot find a variable after searching the entire scope chain during an **RHS lookup**. The variable was never declared in any accessible scope.

    ```javascript
    console.log(undeclaredVar); // ReferenceError: undeclaredVar is not defined
    ```

-   **`TypeError`:** This error occurs when a variable is found, but you attempt to perform an impossible action on its value.

    ```javascript
    var message = "Hello, world!";
    message(); // TypeError: message is not a function
    ```

-   **Accidental Globals:** In non-strict mode, if an **LHS lookup** fails to find a variable, the engine will create a new variable in the **global scope**. This is a common source of bugs and is prevented by using `"use strict";`.

    ```javascript
    function createLeak() {
        // 'userId' was never declared. This will become a global variable.
        userId = 123;
    }
    createLeak();
    console.log(userId); // 123
    ```

### 5\. Quiz: Identifying Lookups

Let's analyze the lookups in this code snippet:

```javascript
function calculateTotal(price) {
    var tax = price * 0.1;
    return price + tax;
}

var total = calculateTotal(100);
```

-   **LHS Lookups (3):**

    1.  `total = ...` (Assigning the function's return value to `total`).
    2.  `price = 100` (Implicitly, when the function is called, the argument `100` is assigned to the parameter `price`).
    3.  `tax = ...` (Assigning the result of the calculation to `tax`).

-   **RHS Lookups (4):**

    1.  `calculateTotal(100)` (Retrieving the function `calculateTotal` to execute it).
    2.  `price * 0.1` (Retrieving the value of `price`).
    3.  `price + tax` (Retrieving the value of `price`).
    4.  `price + tax` (Retrieving the value of `tax`).
