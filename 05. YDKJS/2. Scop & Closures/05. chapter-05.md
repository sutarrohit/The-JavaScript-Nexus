# **Chapter 5: Scope Closure**

### **1. What is Closure?**

-   **Closure** occurs when a function retains access to its lexical scope (variables and references) even when it is executed outside that scope.
-   It allows functions to "remember" and access variables from their original scope, even after the outer function has finished executing.

### **2. How Closure Works**

-   Example:
    ```javascript
    function outer() {
        const a = 2;
        function inner() {
            console.log(a); // Remembers 'a' from outer scope
        }
        return inner;
    }
    const closureFn = outer();
    closureFn(); // 2
    ```
    -   `inner()` maintains access to `a` even after `outer()` has completed execution.

### **3. Common Use Cases**

-   **Data Privacy (Module Pattern):**

    ```javascript
    function createCounter() {
        let count = 0;
        return {
            increment: () => count++,
            getCount: () => count
        };
    }
    const counter = createCounter();
    counter.increment();
    console.log(counter.getCount()); // 1
    ```

    -   `count` is private; only `increment()` and `getCount()` can access it.

-   **Event Handlers & Callbacks:**
    ```javascript
    function setupButton(buttonId) {
        const button = document.getElementById(buttonId);
        button.addEventListener("click", function () {
            console.log("Button clicked:", buttonId);
        });
    }
    setupButton("myBtn");
    ```
    -   The click handler retains access to `buttonId` even after `setupButton()` finishes.

### **4. Loops and Closure**

-   **Problem:**

    ```javascript
    for (var i = 1; i <= 5; i++) {
        setTimeout(() => console.log(i), 1000); // Logs '6' five times
    }
    ```

    -   `var` does not create a new scope per iteration, so all timeouts reference the same `i`.

-   **Solution (Using `let` or IIFE):**

    ```javascript
    // Using `let` (block-scoped)
    for (let i = 1; i <= 5; i++) {
        setTimeout(() => console.log(i), 1000); // Logs 1, 2, 3, 4, 5
    }

    // Using IIFE (pre-ES6)
    for (var i = 1; i <= 5; i++) {
        (function (j) {
            setTimeout(() => console.log(j), 1000); // Logs 1, 2, 3, 4, 5
        })(i);
    }
    ```

### **5. Modules & Closure**

-   **Revealing Module Pattern:**

    ```javascript
    const MyModule = (function () {
        let privateVar = "Secret";

        function privateFn() {
            console.log(privateVar);
        }

        return {
            publicFn: function () {
                privateFn();
            }
        };
    })();

    MyModule.publicFn(); // "Secret"
    ```

    -   Only `publicFn` is exposed; `privateVar` and `privateFn` are hidden.

### **6. Performance Considerations**

-   Closures keep their referenced variables in memory, which can lead to **memory leaks** if not managed properly.
-   Example:
    ```javascript
    function heavyProcess() {
        const largeData = new Array(1000000).fill("data");
        return function () {
            console.log(largeData[0]); // Keeps 'largeData' in memory
        };
    }
    const fn = heavyProcess();
    // 'largeData' remains in memory as long as 'fn' exists
    ```

## **Key Takeaways**

âœ… **Closure** = Function + Lexical Scope.  
âœ… Used for **data encapsulation**, **callbacks**, and **module patterns**.  
âœ… Watch for **loop issues** (`var` vs. `let`).  
âœ… Avoid **memory leaks** by releasing closures when no longer needed.

Closures are everywhere in JavaScriptâ€”once you recognize them, youâ€™ll see them in timers, event handlers, and even modern frameworks! ðŸš€
