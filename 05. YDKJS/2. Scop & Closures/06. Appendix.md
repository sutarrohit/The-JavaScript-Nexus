## Appendix A: Dynamic Scope

Dynamic scope is presented as a contrast to lexical scope, the model used by JavaScript. While lexical scope is determined at the time of authoring, dynamic scope is determined at runtime based on the call-stack.

-   **Core Concept**:

    -   In dynamic scope, if a variable is not found in the current function, the engine checks the scope of the function that _called_ it, continuing up the call-stack.
    -   This is different from lexical scope, which looks at the scope where the function was _declared_.

-   **Illustration**: The appendix provides an example to clarify the difference:

    ```javascript
    function foo() {
        console.log(a);
    }

    function bar() {
        var a = 3;
        foo();
    }

    var a = 2;
    bar();
    ```

-   Under JavaScript's **lexical scope**, the output is `2` because `foo()` resolves `a` to the global scope where it was declared.
-   If JavaScript had **dynamic scope**, the output would be `3`. This is because `foo()` was called from `bar()`, so the engine would find and use the variable `a` from within `bar()`'s scope.

-   **Relation to `this`**:
    -   JavaScript does not have dynamic scope. However, the `this` mechanism in JavaScript is similar, as it is determined at runtime based on how a function is called.

---

## Appendix B: Polyfilling Block Scope

This appendix discusses how to achieve block scope functionality in pre-ES6 JavaScript environments, a process known as "polyfilling."

-   **The `try...catch` Hack**:

    -   ES3 introduced block-scoping for the `catch` clause of a `try...catch` statement. This can be used to polyfill block scope.
    -   **Example of block-scoping with `catch`**:
        ```javascript
        try {
            throw 2;
        } catch (a) {
            console.log(a); // 2
        }
        console.log(a); // ReferenceError
        ```
        The variable `a` only exists within the `catch` block.

-   **Transpilers**:

    -   Manually writing `try...catch` blocks for this purpose is considered impractical. The intended use is through tools called "transpilers" that convert modern code (ES6) into older, compatible versions (ES5).
    -   **Google's Traceur**: This tool transpiles ES6 features into pre-ES6 code and uses the `try...catch` method to polyfill block scope.
    -   **let-er**: A tool created by the author specifically to transpile the `let` statement form into either the `try...catch` polyfill for pre-ES6 environments or into standard ES6 `let` declarations.

-   **Implicit vs. Explicit Blocks**:

    -   The appendix distinguishes between `let` declarations that implicitly use an existing block and the `let` statement form which explicitly creates a block for its scope. The explicit form is argued to be cleaner and more robust, although it is not part of the official ES6 standard.

-   **Performance**:
    -   The `try...catch` method is acknowledged as being slower, but it's noted that performance can be improved and that it is a more suitable general substitute than an IIFE, which can alter the meaning of `this`, `return`, `break`, and `continue`.

---

## Appendix C: Lexical `this`

This section explains the concept of "lexical `this`" introduced in ES6 with arrow functions.

-   **Arrow Functions**:

    -   ES6 introduces arrow functions (`=>`), which provide a shorter syntax for function expressions.
    -   **Example**: `var foo = a => { console.log(a); };`

-   **The `this` Problem**:

    -   A common issue in JavaScript is the loss of `this` binding when a method is passed as a callback. A traditional solution is to use `var self = this;` to create a lexical reference to the desired `this` context.

-   **Lexical `this` Behavior**:

    -   Arrow functions do not have their own `this` binding. Instead, they "inherit" the `this` value from their immediate lexical enclosing scope. This behavior is intended to solve the "this loss" problem.
    -   **Example with Arrow Function**:
        ```javascript
        var obj = {
            count: 0,
            cool: function coolFn() {
                if (this.count < 1) {
                    setTimeout(() => {
                        // arrow-function
                        this.count++;
                        console.log("awesome?");
                    }, 100);
                }
            }
        };
        obj.cool(); // awesome?
        ```
        The arrow function captures the `this` from `coolFn`.

-   **Author's Perspective**:
    -   The author views arrow functions as a codification of a common mistake: confusing `this` binding with lexical scope rules.
    -   He suggests that a more appropriate approach is to correctly use the `this` mechanism, for instance with `.bind(this)`.
    -   He also notes that arrow functions are anonymous, which is less desirable than named functions for readability and debugging.
