## üìù Chapter 3: Function vs. Block Scope

In JavaScript, scope determines the accessibility of variables. Historically, JavaScript only had function scope, but modern versions (ES6+) introduced block scope, which offers more control and helps prevent common bugs.

---

### Function Scope

In traditional JavaScript, the primary unit of scope is the function. When you declare a variable using `var`, it is accessible anywhere within the containing function.

-   **How it works:** A new scope is created for every function. All variables (`var`) and function declarations within that function belong exclusively to it.
-   **Encapsulation:** This behavior is often used to "hide" variables and implementation details from the outside world, preventing naming collisions and unintended modifications.

#### Example: Basic Function Scope

```javascript
function calculatePrice(basePrice) {
    var tax = 0.2; // Scoped to calculatePrice

    function applyTax() {
        // Inner function also has access
        return basePrice * (1 + tax);
    }

    var finalPrice = applyTax();
    return finalPrice;
}

console.log(calculatePrice(100)); // 120
// console.log(tax); // ReferenceError: tax is not defined
```

Here, `tax`, `applyTax`, and `finalPrice` are private to `calculatePrice()` and cannot be accessed from the global scope.

### The Problem with `var` and Function Scope

While useful, function scope with `var` has drawbacks that can lead to bugs.

1.  **Lack of True Block Scope:** Variables declared with `var` inside blocks (like `if` statements or `for` loops) are not scoped to that block. They "leak" into the containing function's scope.

    ```javascript
    function runLoop() {
        for (var i = 0; i < 5; i++) {
            console.log(i); // 0, 1, 2, 3, 4
        }
        console.log(i); // 5 (i is accessible here!)
    }
    ```

2.  **Variable Collision:** Since variables can leak out of blocks, you can accidentally overwrite a variable from an outer scope, which is a common source of bugs.

    ```javascript
    var i = 100;

    function buggyLoop() {
        for (var i = 0; i < 5; i++) {
            // This 'i' is the same as the outer 'i'
        }
    }

    buggyLoop();
    console.log(i); // 5 (The global 'i' was overwritten)
    ```

### IIFE: A Pattern for Isolating Scope

Before modern JavaScript, developers used the **Immediately Invoked Function Expression (IIFE)** pattern to create isolated scope on demand, preventing global scope pollution. An IIFE is a function that is defined and executed immediately.

#### Syntax

```javascript
(function () {
    var message = "This is a private message.";
    console.log(message); // Works here
})();

// console.log(message); // ReferenceError
```

This pattern wraps code in a function, creating a private scope for its variables and preventing them from leaking into the global namespace. It was essential for writing modular and conflict-free code in older JavaScript applications.

---

### Block Scope with `let` and `const`

ES6 introduced two new keywords for variable declaration, `let` and `const`, which provide **block scope**. This means the variable is confined to the nearest `{...}` block it was declared in.

Block scope is more intuitive and helps write safer, cleaner code by limiting a variable's lifespan to precisely where it's needed.

### `let`: The Block-Scoped Variable

The `let` keyword declares a block-scoped variable.

```javascript
function checkWeather(isRaining) {
    if (isRaining) {
        let message = "Bring an umbrella!";
        console.log(message); // "Bring an umbrella!"
    }
    // console.log(message); // ReferenceError: message is not defined
}
```

#### `let` in Loops

`let` is particularly useful in `for` loops. It creates a new binding for each loop iteration, solving a classic problem where closures in loops would all capture the same variable.

```javascript
for (let i = 0; i < 3; i++) {
    setTimeout(function () {
        console.log(i); // Prints 0, then 1, then 2
    }, 100);
}
// With 'var', this would print 3, three times.
```

#### Temporal Dead Zone (TDZ)

Unlike `var` variables (which are "hoisted"), variables declared with `let` and `const` are not accessible before their declaration in the code. The time between entering the block and the variable's declaration is called the **Temporal Dead Zone (TDZ)**.

```javascript
{
    // Start of TDZ for 'score'
    // console.log(score); // ReferenceError
    let score = 100; // End of TDZ for 'score'
}
```

### `const`: Block-Scoped Constants

The `const` keyword works just like `let` in terms of block scope and the TDZ, but with one major difference: the variable's binding is **immutable**. It cannot be reassigned after it's declared.

```javascript
const API_KEY = "xyz123";
// API_KEY = "abc456"; // TypeError: Assignment to constant variable.
```

**Important:** `const` makes the _binding_ constant, not the _value_. If the value is an object or an array, its properties or elements can still be modified.

```javascript
const user = { name: "Alex" };
user.name = "Jordan"; // This is allowed

// user = { name: "Chris" }; // TypeError: Assignment to constant variable.
```

---

### Summary: `var` vs. `let` vs. `const`

Choosing the right keyword for variable declaration is crucial for writing modern, maintainable JavaScript.

| Feature          | `var`                                    | `let`                                 | `const`                                  |
| ---------------- | ---------------------------------------- | ------------------------------------- | ---------------------------------------- |
| **Scope**        | Function Scope                           | **Block Scope** `{...}`               | **Block Scope** `{...}`                  |
| **Hoisting**     | Hoisted and initialized with `undefined` | Hoisted but in TDZ (uninitialized)    | Hoisted but in TDZ (uninitialized)       |
| **Reassignment** | Can be reassigned                        | Can be reassigned                     | **Cannot** be reassigned                 |
| **Best For**     | Legacy code or specific edge cases.      | Variables that need to be reassigned. | Variables that should not be reassigned. |

**Best Practice:** Prefer `const` by default. Use `let` only when you know a variable's value needs to change. Avoid using `var` in modern JavaScript.
