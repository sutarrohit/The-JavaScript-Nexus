# **What is Dynamic SQL?**

**Dynamic SQL** refers to **SQL statements that are constructed and executed at runtime** rather than being written (hardcoded) in the application or database beforehand.

This means:

> The SQL query is **built as a string** â€” possibly based on user input or application logic â€” and then **executed dynamically**.

Itâ€™s often used when the exact structure of the SQL query **cannot be known in advance**.

## ðŸ§  **Static SQL vs Dynamic SQL**

| Feature         | **Static SQL**                                            | **Dynamic SQL**                                  |
| --------------- | --------------------------------------------------------- | ------------------------------------------------ |
| **Definition**  | SQL statements are fixed and written directly in the code | SQL statements are built and executed at runtime |
| **Execution**   | Compiled once                                             | Compiled during runtime                          |
| **Flexibility** | Limited                                                   | Highly flexible                                  |
| **Performance** | Faster (precompiled)                                      | Slightly slower (runtime parsing)                |
| **Security**    | Safer                                                     | Prone to SQL injection if not handled properly   |
| **Use Case**    | When query structure is fixed                             | When query structure changes dynamically         |

---

## âš™ï¸ **When and Why to Use Dynamic SQL**

Dynamic SQL is useful when:

1. You **donâ€™t know the exact structure** of your query at design time.
2. You need to **filter data based on variable user inputs**.
3. You need to **query dynamic table names or column names**.
4. Youâ€™re building **metadata-driven systems** (like reporting dashboards).
5. Youâ€™re implementing **admin tools** that generate queries automatically.

---

## ðŸ§© **Real-Life Example Scenario**

Letâ€™s say you have a web application where a user can search employees by:

-   Department
-   Job title
-   Salary range
-   Location

The user may select **any combination** of filters â€” or none at all.

If you use **static SQL**, youâ€™d need many versions of the same query:

```sql
SELECT * FROM employees
WHERE department = 'IT'
AND job_title = 'Manager'
AND salary > 50000
AND location = 'New York';
```

But what if the user only chooses department and salary?
Youâ€™d need a different query.

Instead, with **Dynamic SQL**, you can build the query **on the fly** based on user input.

---

## ðŸ§± **Example â€” Dynamic SQL in SQL Server**

### ðŸ§  Step 1: Build the SQL string dynamically

```sql
DECLARE @sql NVARCHAR(MAX);
DECLARE @department NVARCHAR(50) = 'IT';
DECLARE @job_title NVARCHAR(50) = NULL;
DECLARE @location NVARCHAR(50) = 'New York';

SET @sql = 'SELECT * FROM employees WHERE 1=1';  -- base query

IF @department IS NOT NULL
    SET @sql = @sql + ' AND department = ''' + @department + '''';

IF @job_title IS NOT NULL
    SET @sql = @sql + ' AND job_title = ''' + @job_title + '''';

IF @location IS NOT NULL
    SET @sql = @sql + ' AND location = ''' + @location + '''';

PRINT @sql;  -- for debugging

EXEC sp_executesql @sql;  -- executes the dynamic SQL
```

### ðŸ” Output query executed:

```sql
SELECT * FROM employees
WHERE 1=1
AND department = 'IT'
AND location = 'New York';
```

âœ… This way, only **user-selected filters** are added to the query.

---

## ðŸ§  **How Dynamic SQL Works**

1. You **build a string** containing the SQL statement dynamically.
2. You **concatenate conditions**, table names, or parameters into that string.
3. You **execute the string** using a special database function or command:

    - SQL Server â†’ `EXEC` or `sp_executesql`
    - Oracle â†’ `EXECUTE IMMEDIATE`
    - MySQL â†’ `PREPARE` + `EXECUTE`
    - PostgreSQL â†’ `EXECUTE` inside `PL/pgSQL`

---

## ðŸ§° **Examples Across Databases**

### ðŸ”¹ **SQL Server Example**

```sql
DECLARE @sql NVARCHAR(MAX) = 'SELECT * FROM products WHERE category_id = @cat';
EXEC sp_executesql @sql, N'@cat INT', @cat = 5;
```

### ðŸ”¹ **Oracle Example**

```sql
DECLARE
  sql_stmt VARCHAR2(1000);
BEGIN
  sql_stmt := 'DELETE FROM employees WHERE department_id = :dept_id';
  EXECUTE IMMEDIATE sql_stmt USING 10;
END;
```

### ðŸ”¹ **MySQL Example**

```sql
SET @dept = 'IT';
SET @sql = CONCAT('SELECT * FROM employees WHERE department = "', @dept, '"');
PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
```

### ðŸ”¹ **PostgreSQL Example**

```sql
DO $$
DECLARE
  dept text := 'IT';
  sql text;
BEGIN
  sql := format('SELECT * FROM employees WHERE department = %L', dept);
  EXECUTE sql;
END $$;
```

---

## ðŸ§  **Use Cases of Dynamic SQL**

| Use Case                              | Example                                               |
| ------------------------------------- | ----------------------------------------------------- |
| **Conditional filtering**             | Build WHERE clauses based on user input               |
| **Dynamic table or column selection** | Query different tables dynamically                    |
| **Metadata-driven systems**           | Query tables based on schema info                     |
| **Bulk DDL/DML**                      | Generate and execute table creation or update scripts |
| **Dynamic pivoting/unpivoting**       | Create dynamic reports                                |

---

## âš ï¸ **Security Risks â€” SQL Injection**

### âŒ Problem

When you concatenate **unvalidated user input** directly into your query string, attackers can inject malicious SQL code.

Example of **vulnerable code**:

```sql
DECLARE @username NVARCHAR(50) = 'admin''; DROP TABLE users; --';
DECLARE @sql NVARCHAR(MAX) = 'SELECT * FROM users WHERE username = ''' + @username + '''';
EXEC(@sql);
```

The resulting query becomes:

```sql
SELECT * FROM users WHERE username = 'admin'; DROP TABLE users; --'
```

âž¡ï¸ This would **delete your `users` table!**

---

## âœ… **How to Prevent SQL Injection**

### 1. **Use Parameterized Queries**

Instead of concatenating strings, use parameters.

```sql
DECLARE @sql NVARCHAR(MAX);
SET @sql = 'SELECT * FROM users WHERE username = @user';
EXEC sp_executesql @sql, N'@user NVARCHAR(50)', @user = 'admin';
```

### 2. **Validate and Sanitize Inputs**

-   Check data type, length, and allowed values before building queries.
-   Reject unexpected characters (like `'`, `;`, `--`).

### 3. **Least Privilege Principle**

Give database users only the permissions they need â€” not `DROP` or `ALTER`.

### 4. **Use Stored Procedures (with parameters)**

Dynamic SQL can be safely used **inside stored procedures** that handle input securely.

---

## âš™ï¸ **Performance Considerations**

| Factor                     | Effect                                                                                            |
| -------------------------- | ------------------------------------------------------------------------------------------------- |
| **Execution plan caching** | Static SQL caches plans easily; dynamic SQL might not. Use parameterized dynamic SQL for caching. |
| **Compilation overhead**   | Dynamic SQL compiles at runtime, so frequent execution can slow performance.                      |
| **Flexibility tradeoff**   | Gain flexibility at the cost of some runtime overhead.                                            |

---

## ðŸ§© **Advantages of Dynamic SQL**

| Advantage                          | Description                                       |
| ---------------------------------- | ------------------------------------------------- |
| **Flexibility**                    | Build queries based on runtime input              |
| **Reusability**                    | Write one query template for many variations      |
| **Powerful for automation**        | Generate queries programmatically                 |
| **Ideal for metadata-driven apps** | Reporting systems, admin tools, dynamic filtering |

---

## âš ï¸ **Disadvantages**

| Disadvantage             | Description                                           |
| ------------------------ | ----------------------------------------------------- |
| **SQL Injection risk**   | Unvalidated input can lead to serious attacks         |
| **Complex debugging**    | Dynamically built strings can be hard to troubleshoot |
| **Performance overhead** | Each dynamic query may require recompilation          |
| **Readability issues**   | Code can become difficult to maintain if overused     |

---

## ðŸ§  **Summary**

| Feature                 | Description                                                |
| ----------------------- | ---------------------------------------------------------- |
| **Definition**          | SQL built and executed at runtime                          |
| **Use Cases**           | Flexible search, dynamic filters, variable table names     |
| **Advantages**          | Highly flexible, reusable, adaptable                       |
| **Risks**               | SQL injection, runtime errors                              |
| **Mitigation**          | Always use parameters and input validation                 |
| **Execution Functions** | `sp_executesql`, `EXECUTE IMMEDIATE`, `PREPARE`, `EXECUTE` |

---

## ðŸ’¡ **Key Takeaway**

> Use **Dynamic SQL** when you need flexibility and cannot predict query structure at design time â€”
> but always **validate inputs** and **use parameters** to prevent SQL injection.
