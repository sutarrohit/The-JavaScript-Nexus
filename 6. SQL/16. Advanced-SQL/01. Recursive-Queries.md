# 1. **Advanced SQL Concepts**

**Definition:**
Advanced SQL concepts go beyond simple `SELECT`, `INSERT`, `UPDATE`, and `DELETE` operations. They involve techniques and features used for **complex data manipulation**, **optimization**, and **business logic implementation** within a database.

These concepts help **database developers**, **data analysts**, and **DBAs** (Database Administrators) handle **large datasets**, **complicated relationships**, and **high-performance requirements** in **enterprise-level systems**.

### ‚öôÔ∏è **Benefits of Advanced SQL Concepts**

1. **Performance Optimization** ‚Äî Faster queries using indexes, CTEs, and optimized joins.
2. **Reusability & Maintainability** ‚Äî Stored procedures and functions make code modular.
3. **Data Integrity** ‚Äî Triggers and constraints ensure consistent and valid data.
4. **Scalability** ‚Äî Efficient querying methods handle millions of records.
5. **Complex Analysis** ‚Äî Window functions and recursive queries allow deep insights.

---

# 2. **What Are Recursive Queries?**

A **recursive query** is a query that **refers to itself** to retrieve hierarchical or self-referential data.
It is typically written using a **Common Table Expression (CTE)** with the `WITH RECURSIVE` clause.

Recursive queries are especially useful when dealing with **hierarchical data** like:

-   Employee-manager relationships (organization chart)
-   Folder structures (nested directories)
-   Bill of materials (product components)
-   Family trees
-   Graph or network traversal (e.g., finding connections or dependencies)

## ‚öôÔ∏è **Structure of a Recursive Query**

A recursive query consists of **three main parts:**

### 1. **Anchor Member (Base Case)**

-   This is the **starting point** of the recursion.
-   It retrieves the initial or top-level data (like the root node in a hierarchy).

### 2. **Recursive Member**

-   This part **references the CTE itself** to retrieve the next level of data.
-   It continues to execute repeatedly until no new rows are returned.

### 3. **Termination**

-   Recursion stops automatically when the recursive member **returns no new rows**.

### General Syntax:

```sql
WITH RECURSIVE cte_name AS (
    -- 1Ô∏è‚É£ Anchor Member: Base query (non-recursive)
    SELECT ...
    FROM ...
    WHERE ...  -- Base condition (e.g., top-level node)

    UNION ALL

    -- 2Ô∏è‚É£ Recursive Member: Refers to the CTE itself
    SELECT ...
    FROM ...
    JOIN cte_name ON ... -- recursion condition
)
-- 3Ô∏è‚É£ Final Query
SELECT * FROM cte_name;
```

---

## üìò **Example 1: Employee Hierarchy**

Imagine you have an `employees` table like this:

| employee_id | name    | manager_id |
| ----------- | ------- | ---------- |
| 1           | Alice   | NULL       |
| 2           | Bob     | 1          |
| 3           | Charlie | 2          |
| 4           | David   | 2          |
| 5           | Eve     | 3          |

Here, `manager_id` points to another `employee_id` ‚Äî a classic **self-referential relationship**.

### ‚úÖ Recursive Query to Find All Employees Under Alice

```sql
WITH RECURSIVE employee_hierarchy AS (
    -- Anchor member: Find Alice (top-level manager)
    SELECT employee_id, name, manager_id
    FROM employees
    WHERE name = 'Alice'

    UNION ALL

    -- Recursive member: Find employees managed by anyone already in the hierarchy
    SELECT e.employee_id, e.name, e.manager_id
    FROM employees e
    INNER JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT * FROM employee_hierarchy;
```

### üß† What Happens Step-by-Step:

1. **Anchor query** finds `Alice` (manager_id = NULL).
2. **Recursive query** finds employees who have `manager_id = Alice‚Äôs employee_id`.

    - That‚Äôs `Bob` (manager_id = 1).

3. Then it finds employees who report to `Bob`:

    - `Charlie` and `David`.

4. Then it finds employees who report to `Charlie`:

    - `Eve`.

5. Finally, recursion stops when no more matches are found.

### üßæ Output:

| employee_id | name    | manager_id |
| ----------- | ------- | ---------- |
| 1           | Alice   | NULL       |
| 2           | Bob     | 1          |
| 3           | Charlie | 2          |
| 4           | David   | 2          |
| 5           | Eve     | 3          |

---

## üìò **Example 2: Directory Structure (Tree Traversal)**

| id  | folder_name | parent_id |
| --- | ----------- | --------- |
| 1   | Root        | NULL      |
| 2   | Documents   | 1         |
| 3   | Images      | 1         |
| 4   | Work        | 2         |
| 5   | Personal    | 2         |

```sql
WITH RECURSIVE folder_tree AS (
    -- Anchor: start at the root
    SELECT id, folder_name, parent_id, folder_name AS path
    FROM folders
    WHERE parent_id IS NULL

    UNION ALL

    -- Recursive: join to get subfolders
    SELECT f.id, f.folder_name, f.parent_id, CONCAT(ft.path, '/', f.folder_name)
    FROM folders f
    INNER JOIN folder_tree ft ON f.parent_id = ft.id
)
SELECT * FROM folder_tree;
```

### üßæ Output:

| id  | folder_name | parent_id | path                    |
| --- | ----------- | --------- | ----------------------- |
| 1   | Root        | NULL      | Root                    |
| 2   | Documents   | 1         | Root/Documents          |
| 3   | Images      | 1         | Root/Images             |
| 4   | Work        | 2         | Root/Documents/Work     |
| 5   | Personal    | 2         | Root/Documents/Personal |

This builds a **hierarchical folder path** dynamically ‚Äî a perfect real-world use case for recursion.

---

## üß† **Key Characteristics**

| Feature                       | Description                                                                     |
| ----------------------------- | ------------------------------------------------------------------------------- |
| **Self-reference**            | Recursive part refers to the CTE name itself                                    |
| **Termination**               | Stops when no new rows are produced                                             |
| **UNION ALL**                 | Used to combine anchor and recursive results (ALL is preferred for performance) |
| **Hierarchy traversal**       | Allows moving up/down in a tree or graph                                        |
| **Performance consideration** | Should be used carefully; deep recursion can be costly                          |

---

## ‚ö° **Performance Tips**

1. **Use proper indexes** on the columns used in the join condition (e.g., `manager_id`).

2. Avoid unnecessary columns ‚Äî only select what‚Äôs needed.

3. If your DBMS supports it, **limit recursion depth** using:

    ```sql
    OPTION (MAXRECURSION 10);
    ```

    _(SQL Server specific)_

4. **Monitor recursion** ‚Äî infinite recursion can happen if base conditions are missing.

---

## üß© **Supported Databases**

Recursive CTEs are supported by most modern RDBMS:

-   ‚úÖ PostgreSQL
-   ‚úÖ MySQL (8.0+)
-   ‚úÖ SQL Server
-   ‚úÖ SQLite
-   ‚úÖ Oracle (from 11gR2 via `CONNECT BY` or CTE)

---

## üí° **Summary**

| Concept        | Explanation                                                          |
| -------------- | -------------------------------------------------------------------- |
| **Purpose**    | To handle hierarchical or self-referential data                      |
| **Components** | Anchor query + Recursive query                                       |
| **Syntax**     | `WITH RECURSIVE cte_name AS (...)`                                   |
| **Stops When** | Recursive part returns no new rows                                   |
| **Use Cases**  | Employee hierarchies, file systems, dependency trees, network graphs |
