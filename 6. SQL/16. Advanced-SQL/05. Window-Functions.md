# **1. Window Functions**

**Definition:**
Window functions perform calculations across a _set of rows that are related to the current row_ ‚Äî this set is called a **window frame**.

Unlike aggregate functions (like `SUM`, `AVG`, `COUNT`) which collapse multiple rows into one, **window functions preserve each row** while still performing aggregate-like calculations.

---

### ‚úÖ **General Syntax**

```sql
<window_function>(<expression>)
OVER (
    [PARTITION BY <column_list>]
    [ORDER BY <column_list>]
    [ROWS or RANGE <frame_specification>]
)
```

**Explanation:**

-   `OVER()` ‚Üí Defines the _window_ of rows to perform the calculation on.
-   `PARTITION BY` ‚Üí Divides the result set into groups (like `GROUP BY`, but doesn‚Äôt collapse rows).
-   `ORDER BY` ‚Üí Orders the rows within each partition.
-   `ROWS` / `RANGE` ‚Üí Defines the subset of rows within the partition (optional).

---

## ü™ü **2. Types of Window Functions**

### üß© **A. Ranking Functions**

Used to assign rank or sequence numbers to rows.

---

### üîπ **`ROW_NUMBER()`**

Assigns a **unique sequential number** to each row within a partition.
Even if two rows have the same value in the ordering column, they get **different numbers**.

#### Example:

```sql
SELECT
    department,
    employee_name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num
FROM employees;
```

#### Explanation:

-   Each department forms a **partition**.
-   Employees are ordered by salary (highest first).
-   `ROW_NUMBER()` assigns `1, 2, 3, ‚Ä¶` to each employee per department.

#### Use Cases:

-   Implementing **pagination** (like showing top 10 results).
-   Finding the **nth highest value**.
-   Removing duplicates.

---

### üîπ **`RANK()`**

Assigns a **rank** to each row, but **leaves gaps** in the ranking when there are ties.

#### Example:

```sql
SELECT
    employee_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;
```

#### Explanation:

If two employees have the same salary, they get the same rank, and the next rank is **skipped**.

| Employee | Salary | RANK() |
| -------- | ------ | ------ |
| John     | 90000  | 1      |
| Sarah    | 85000  | 2      |
| Alex     | 85000  | 2      |
| Mike     | 80000  | 4      |

Notice: Rank `3` is skipped.

#### Use Case:

-   Ranking items (e.g., competition standings where ties skip numbers).

---

### üîπ **`DENSE_RANK()`**

Similar to `RANK()`, but **no ranks are skipped** when ties occur.

#### Example:

```sql
SELECT
    employee_name,
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_dense_rank
FROM employees;
```

| Employee | Salary | DENSE_RANK() |
| -------- | ------ | ------------ |
| John     | 90000  | 1            |
| Sarah    | 85000  | 2            |
| Alex     | 85000  | 2            |
| Mike     | 80000  | 3            |

Here, rank numbers are **continuous**.

#### Use Case:

-   Ranking where **ties shouldn‚Äôt create gaps** (like placing in competitions or leaderboards).

---

## üîÅ **B. Value Access Functions**

Used to **compare values between rows** within the same result set.

---

### üîπ **`LAG()`**

Fetches data from a **previous row** relative to the current row, within the same partition.

#### Syntax:

```sql
LAG(column_name, [offset], [default_value])
OVER (PARTITION BY ... ORDER BY ...)
```

#### Example:

```sql
SELECT
    month,
    revenue,
    LAG(revenue, 1, 0) OVER (ORDER BY month) AS prev_month_revenue,
    revenue - LAG(revenue, 1, 0) OVER (ORDER BY month) AS revenue_change
FROM sales;
```

#### Explanation:

-   Looks **1 row before** the current row.
-   If there‚Äôs no previous row, returns **0** (default value).
-   Used here to compute the **month-over-month change**.

#### Use Case:

-   Comparing current vs previous values (e.g., growth rate, stock price change).

---

### üîπ **`LEAD()`**

The opposite of `LAG()` ‚Äî fetches data from a **next row** relative to the current row.

#### Syntax:

```sql
LEAD(column_name, [offset], [default_value])
OVER (PARTITION BY ... ORDER BY ...)
```

#### Example:

```sql
SELECT
    month,
    revenue,
    LEAD(revenue, 1, 0) OVER (ORDER BY month) AS next_month_revenue
FROM sales;
```

#### Explanation:

-   Retrieves the value from the **next** row in sequence.
-   Can help with **future comparisons or forecasting**.

#### Use Case:

-   Comparing current and next data points.
-   Identifying when a value is about to rise or drop.

---

## ‚öôÔ∏è **3. How Window Functions Differ from Aggregate Functions**

| Feature     | Aggregate Function (`SUM`, `AVG`) | Window Function                        |
| ----------- | --------------------------------- | -------------------------------------- |
| Output      | Collapses rows into one per group | Keeps all rows                         |
| Clause      | Uses `GROUP BY`                   | Uses `OVER()`                          |
| Flexibility | Limited (no row-level context)    | Can compare rows dynamically           |
| Example     | `SUM(salary) GROUP BY dept`       | `SUM(salary) OVER (PARTITION BY dept)` |

---

### Example Comparison:

**Aggregate Query:**

```sql
SELECT department, SUM(salary)
FROM employees
GROUP BY department;
```

‚û°Ô∏è One row per department.

**Window Query:**

```sql
SELECT
    employee_name,
    department,
    salary,
    SUM(salary) OVER (PARTITION BY department) AS dept_total_salary
FROM employees;
```

‚û°Ô∏è Each employee row still shown, but includes department total.

---

## üßÆ **4. Practical Example (Combined Use)**

```sql
SELECT
    department,
    employee_name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num,
    RANK()       OVER (PARTITION BY department ORDER BY salary DESC) AS rank_num,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dense_rank_num,
    LAG(salary)  OVER (PARTITION BY department ORDER BY salary DESC) AS prev_salary,
    LEAD(salary) OVER (PARTITION BY department ORDER BY salary DESC) AS next_salary
FROM employees;
```

#### Output Interpretation:

| Dept | Employee | Salary | Row_Num | Rank | Dense_Rank | Prev_Salary | Next_Salary |
| ---- | -------- | ------ | ------- | ---- | ---------- | ----------- | ----------- |
| HR   | Alice    | 90000  | 1       | 1    | 1          | NULL        | 85000       |
| HR   | Bob      | 85000  | 2       | 2    | 2          | 90000       | 70000       |
| HR   | Charlie  | 70000  | 3       | 3    | 3          | 85000       | NULL        |

---

## üß© **5. Common Use Cases**

| Use Case                                | Example Function                |
| --------------------------------------- | ------------------------------- |
| Pagination                              | `ROW_NUMBER()`                  |
| Ranking top performers                  | `RANK()`, `DENSE_RANK()`        |
| Change analysis (previous vs current)   | `LAG()`                         |
| Predictive comparison (current vs next) | `LEAD()`                        |
| Cumulative totals                       | `SUM() OVER (ORDER BY ...)`     |
| Running averages                        | `AVG() OVER (ROWS BETWEEN ...)` |

---

## üß≠ **6. Summary Table**

| Function       | Purpose                   | Handles Ties? | Skips Ranks? | Direction           |
| -------------- | ------------------------- | ------------- | ------------ | ------------------- |
| `ROW_NUMBER()` | Assigns sequential number | ‚ùå            | ‚úÖ           | Sequential          |
| `RANK()`       | Assigns rank with gaps    | ‚úÖ            | ‚úÖ           | Based on `ORDER BY` |
| `DENSE_RANK()` | Assigns rank without gaps | ‚úÖ            | ‚ùå           | Based on `ORDER BY` |
| `LAG()`        | Access previous row       | ‚Äî             | ‚Äî            | Looks backward      |
| `LEAD()`       | Access next row           | ‚Äî             | ‚Äî            | Looks forward       |
