# **What Are Common Table Expressions (CTEs)?**

A **CTE (Common Table Expression)** is a **temporary named result set** defined within the execution scope of a single SQL statement.

You can think of it as:

> A _temporary view_ or _inline virtual table_ that exists only during the execution of one query.

CTEs help you structure complex SQL queries into logical building blocks, making them **easier to read, debug, and maintain**.

## ‚öôÔ∏è **CTE Syntax**

```sql
WITH cte_name AS (
    -- SQL query that defines the temporary result set
    SELECT ...
    FROM ...
    WHERE ...
)
-- You can now reference the CTE in the main query
SELECT *
FROM cte_name
WHERE ...
```

### üß† Key Points

-   The `WITH` clause introduces the CTE.
-   `cte_name` is the **alias** for the temporary result set.
-   It can be referenced **like a table or view** within the query that follows.
-   The CTE **only exists during that query‚Äôs execution** (not stored permanently).

---

## üìò **Example 1 ‚Äî Simplifying a Complex Query**

Let‚Äôs say you want to find **employees who earn more than the average salary** in each department.

Without CTE:

```sql
SELECT e.employee_id, e.name, e.department_id, e.salary
FROM employees e
WHERE e.salary > (
    SELECT AVG(salary)
    FROM employees
    WHERE department_id = e.department_id
);
```

This works but is hard to read and maintain.

---

### ‚úÖ Using a CTE for Clarity:

```sql
WITH department_avg AS (
    SELECT department_id, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
)
SELECT e.employee_id, e.name, e.department_id, e.salary
FROM employees e
JOIN department_avg d
ON e.department_id = d.department_id
WHERE e.salary > d.avg_salary;
```

### üí° Why it‚Äôs better:

-   Easier to understand.
-   Avoids repeating logic.
-   Improves maintainability.

---

## üß© **Types of CTEs**

There are **two main types**:

| Type                  | Description                                                      |
| --------------------- | ---------------------------------------------------------------- |
| **Non-Recursive CTE** | Used to simplify complex queries; does _not_ reference itself.   |
| **Recursive CTE**     | Refers to itself to handle hierarchical or tree-structured data. |

Let‚Äôs explore both.

---

## üìò **1. Non-Recursive CTE**

Used for **query simplification** ‚Äî a modular way to build multi-step logic.

### Example: Breaking Down Calculations

```sql
WITH total_sales AS (
    SELECT customer_id, SUM(amount) AS total
    FROM sales
    GROUP BY customer_id
),
top_customers AS (
    SELECT customer_id
    FROM total_sales
    WHERE total > 10000
)
SELECT c.customer_id, c.total
FROM total_sales c
JOIN top_customers t ON c.customer_id = t.customer_id;
```

Here:

1. `total_sales` CTE calculates total sales per customer.
2. `top_customers` CTE filters high-value customers.
3. The final query joins both for results.

‚úÖ This is cleaner and more efficient than using nested subqueries.

---

## üìò **2. Recursive CTE**

Recursive CTEs are used to **process hierarchical data**, like:

-   Employee ‚Üí Manager relationships
-   Directory trees
-   Bill of materials
-   Graph traversal

They contain **two parts**:

1. **Anchor Member** ‚Äî base result (starting point)
2. **Recursive Member** ‚Äî references itself
3. **Termination Condition** ‚Äî recursion stops automatically when no new rows are returned

### Example: Employee Hierarchy

```sql
WITH RECURSIVE employee_hierarchy AS (
    -- Anchor member: start with top-level manager
    SELECT employee_id, name, manager_id, 1 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive member: find direct reports
    SELECT e.employee_id, e.name, e.manager_id, eh.level + 1
    FROM employees e
    INNER JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT * FROM employee_hierarchy;
```

This will return **every employee** in the company along with their **hierarchical level**.

---

## üßÆ **CTEs vs Subqueries vs Views**

| Feature               | CTE                                       | Subquery         | View                            |
| --------------------- | ----------------------------------------- | ---------------- | ------------------------------- |
| **Scope**             | Within one query                          | Within one query | Permanent (stored in DB)        |
| **Reusability**       | Yes (within same query)                   | No               | Yes (across sessions)           |
| **Readability**       | Very high                                 | Moderate         | High                            |
| **Performance**       | Similar to subquery (optimizer-dependent) | Similar          | Sometimes better (indexed view) |
| **Recursion Support** | ‚úÖ Yes                                    | ‚ùå No            | ‚ùå No                           |

---

## ‚ö° **Advantages of Using CTEs**

| Benefit                    | Description                                                |
| -------------------------- | ---------------------------------------------------------- |
| **Improved readability**   | Complex logic becomes modular and understandable           |
| **Reusability**            | The same temporary result can be referenced multiple times |
| **Supports recursion**     | Enables hierarchical queries                               |
| **Simplifies maintenance** | Easier to change logic in one place                        |
| **Better debugging**       | You can test each CTE individually                         |
| **Scoped to one query**    | Automatically cleaned up after execution                   |

---

## ‚öôÔ∏è **Performance Considerations**

-   Most databases **treat CTEs like inline views**, so performance is similar to equivalent subqueries.
-   In SQL Server, **non-materialized CTEs** are expanded at runtime.
-   In PostgreSQL (before v12), CTEs were **always materialized** (which could hurt performance), but now they can be inlined by the optimizer.
-   You can use **temporary tables** instead of CTEs when the same dataset needs to be reused across multiple queries.

---

## üß† **Real-World Use Cases**

| Use Case                     | Example                                                  |
| ---------------------------- | -------------------------------------------------------- |
| **Breaking complex queries** | Divide long multi-join queries into readable sections    |
| **Recursive hierarchy**      | Employee-manager trees, category hierarchies             |
| **Filtering stages**         | Use multiple CTEs to filter and refine data step-by-step |
| **Aggregations**             | Compute totals first, then filter or join                |
| **Ranking and analytics**    | Combine with `ROW_NUMBER()`, `RANK()`, etc.              |

---

## üí° **Multiple CTEs in a Single Query**

You can define **multiple CTEs** by separating them with commas:

```sql
WITH sales_cte AS (
    SELECT customer_id, SUM(amount) AS total
    FROM sales
    GROUP BY customer_id
),
discount_cte AS (
    SELECT customer_id, discount
    FROM customer_discounts
)
SELECT s.customer_id, s.total, d.discount
FROM sales_cte s
JOIN discount_cte d ON s.customer_id = d.customer_id;
```

Each CTE builds on the previous one, forming a clear data pipeline.

---

## üßæ **Supported Databases**

| Database          | Syntax                 |
| ----------------- | ---------------------- |
| **PostgreSQL**    | `WITH [RECURSIVE] ...` |
| **SQL Server**    | `WITH ...`             |
| **Oracle (12c+)** | `WITH ...`             |
| **MySQL (8.0+)**  | `WITH [RECURSIVE] ...` |
| **SQLite**        | `WITH [RECURSIVE] ...` |

---

## üß† **Summary Table**

| Feature           | Description                                                  |
| ----------------- | ------------------------------------------------------------ |
| **Definition**    | Temporary named result set used within a single query        |
| **Introduced By** | `WITH` clause                                                |
| **Scope**         | Only valid for that query                                    |
| **Types**         | Non-recursive and recursive                                  |
| **Advantages**    | Improves readability, supports recursion, modular structure  |
| **Use Cases**     | Simplify logic, handle hierarchies, step-by-step computation |
