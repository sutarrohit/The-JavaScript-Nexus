# Nested vs Correlated Subqueries

Nice — let’s unpack both concepts thoroughly, show how they run, how they differ, and how to write/optimize them. I’ll use short, concrete examples (mostly reusing your `CUSTOMERS` table) and explain _step-by-step_ what the database does.

---

## 1) Quick definitions

-   **Subquery** = any `SELECT` used inside another query (in `WHERE`, `FROM`, `SELECT`, etc.).
-   **Nested subquery** = a subquery that itself contains another subquery (one or more levels deep).
-   **Correlated subquery** = a subquery that refers to columns of the _outer_ query; it depends on the current outer row and is (conceptually) evaluated once per outer row.

---

## 2) Non-correlated nested subqueries (simple case)

**Example schema** (shortened):

```sql
CUSTOMERS(id, name, age, address, salary)
```

**Single-level (non-correlated) subquery:**

```sql
SELECT *
FROM CUSTOMERS
WHERE id IN (
    SELECT id FROM CUSTOMERS WHERE salary > 4500
);
```

**How it executes (conceptually):**

1. DB runs the inner query `SELECT id FROM CUSTOMERS WHERE salary > 4500` → produces a result set (e.g. `{4,5,7}`).
2. Outer query uses that result set as a filter: `WHERE id IN (4,5,7)` and returns matching rows.

**Nested subquery (multi-level):**

```sql
SELECT * FROM A
WHERE x IN (
  SELECT x FROM B WHERE y IN (
    SELECT y FROM C WHERE z = 10
  )
);
```

Execution (conceptually):

1. Evaluate deepest `SELECT y FROM C WHERE z = 10`.
2. Plug results into the next level: `SELECT x FROM B WHERE y IN (...)`.
3. Use those results in the outer `A` query.

**Notes:**

-   Non-correlated subqueries can be executed once and their results reused.
-   They can return a scalar, row, column, or table (depending on context).

---

## 3) Correlated subqueries — definition & examples

**Correlated subquery example:** find customers whose salary is above the average salary _of customers from the same city_:

```sql
SELECT c1.id, c1.name, c1.salary, c1.address
FROM CUSTOMERS c1
WHERE c1.salary > (
  SELECT AVG(c2.salary)
  FROM CUSTOMERS c2
  WHERE c2.address = c1.address    -- <-- correlation here
);
```

**What “correlated” means:**

-   The inner query references `c1.address` — a column from the outer row.
-   The DB cannot run that inner query just once; conceptually it must evaluate it for each row of `c1` (i.e., for each customer).

**Conceptual evaluation:**
For each row `c1`:

1. Compute `AVG(c2.salary)` where `c2.address = c1.address`.
2. Compare `c1.salary` to that average.
3. If `TRUE`, include `c1` in the final result.

**Important behavior:**

-   Correlated subqueries can be expensive if naively executed row-by-row.
-   Modern DB engines often optimize correlated subqueries (rewrite to joins, semi-joins, or caches) when possible.

---

## 4) Correlated `EXISTS` — common and efficient pattern

`EXISTS` checks whether the inner query finds at least one row. It's frequently used with correlation and is often faster than `IN` for existence checks:

```sql
SELECT c.*
FROM CUSTOMERS c
WHERE EXISTS (
  SELECT 1 FROM ORDERS o
  WHERE o.customer_id = c.id   -- correlated
    AND o.total > 100
);
```

**Why `EXISTS` can be faster:**

-   The inner query can stop at the first matching row (short-circuit).
-   DB can convert it to a semi-join internally.

---

## 5) `IN` vs `EXISTS` vs `ANY/ALL` — semantics & NULLs

-   `IN (subquery)` checks membership. If the subquery returns `NULL` values and _no_ definite matches, `IN` can evaluate to `UNKNOWN` (treated as false in `WHERE`). That can surprise you.
-   `EXISTS` only cares if at least one row is produced; it doesn’t care about the column values or `NULL`s.
-   `ANY` / `SOME` / `ALL` allow comparisons to any/all values from a single-column subquery:

    -   `x > ANY (sub)` → true if `x` > at least one value from `sub`.
    -   `x > ALL (sub)` → true if `x` > every value from `sub`.

**Tip:** use `EXISTS` for existence checks, and prefer `JOIN` or window functions where appropriate for comparisons/aggregations.

---

## 6) Examples using `INSERT`, `UPDATE`, `DELETE`

**INSERT from a subquery:**

```sql
INSERT INTO CUSTOMERS_BKP
SELECT * FROM CUSTOMERS WHERE id IN (SELECT id FROM CUSTOMERS);
```

**UPDATE using correlated subquery:**

```sql
-- give every customer the average salary of their city (example)
UPDATE CUSTOMERS c
SET salary = (
  SELECT AVG(c2.salary)
  FROM CUSTOMERS c2
  WHERE c2.address = c.address
);
```

(Behavior and syntax vary across RDBMS; some DBs require different aliasing.)

**DELETE using subquery:**

```sql
DELETE FROM CUSTOMERS
WHERE age IN (SELECT age FROM CUSTOMERS_BKP WHERE age >= 27);
```

---

## 7) Performance considerations & optimizations

### Why correlated subqueries can be slow

-   Naive execution evaluates inner query per outer row → O(rows_outer × cost_inner).
-   If inner subquery scans a large table every time, it’s expensive.

### How to optimize

1. **Rewrite as JOIN or window function** when possible — often much faster:

    - Correlated aggregation example rewritten using window functions:

```sql
-- correlated subquery (slower)
SELECT id, name, salary
FROM CUSTOMERS c1
WHERE salary > (
  SELECT AVG(c2.salary)
  FROM CUSTOMERS c2
  WHERE c2.address = c1.address
);

-- rewrite with window function (faster)
SELECT id, name, salary
FROM (
  SELECT *, AVG(salary) OVER (PARTITION BY address) AS avg_addr_sal
  FROM CUSTOMERS
) t
WHERE salary > avg_addr_sal;
```

2. **Use JOINs / derived tables**:

```sql
SELECT c.*
FROM CUSTOMERS c
JOIN (
  SELECT address, AVG(salary) AS avg_sal
  FROM CUSTOMERS
  GROUP BY address
) agg ON c.address = agg.address
WHERE c.salary > agg.avg_sal;
```

3. **Add proper indexes** on correlated columns (e.g., `address`, `customer_id`) so the inner lookup is fast.

4. **Use `EXISTS`** when you only need to know if matching rows exist.

5. **Use `LATERAL` / `CROSS APPLY`** (Postgres / SQL Server) when a subquery must be evaluated per outer row and produce columns:

```sql
-- Postgres example: top order per customer
SELECT c.id, c.name, o.*
FROM customers c
CROSS JOIN LATERAL (
  SELECT * FROM orders o WHERE o.customer_id = c.id
  ORDER BY o.order_date DESC
  LIMIT 1
) o;
```

`LATERAL` is explicit about per-row dependency and often clearer than correlated scalar subqueries.

---

## 8) When to use nested/correlated subqueries

-   Use **non-correlated subqueries** when the inner result is independent of the outer query (it can be precomputed).
-   Use **correlated subqueries** when the inner value depends on the current outer row (e.g., per-row aggregation, per-row existence).
-   Prefer **joins** or **window functions** for performance and clarity when they express the same logic.
-   Use **LATERAL/CROSS APPLY** when you need per-row derived columns or “top N per group” logic.

---

## 9) Common pitfalls & gotchas

-   **NULL handling**: `IN` can behave counterintuitively with `NULL`. Prefer `EXISTS` or explicit `IS NOT NULL` checks if unsure.
-   **ORDER BY in subqueries**: standard SQL disallows `ORDER BY` inside subqueries unless paired with `LIMIT`/`TOP` or used with window functions.
-   **Scalar subqueries must return 1 value** — if they return multiple rows you’ll get an error.
-   **Syntax differences**: small variations exist across MySQL, Postgres, SQL Server, Oracle for `UPDATE` aliasing, `LATERAL`, etc.
-   **Readability**: overly-nested subqueries are hard to read — consider CTEs (`WITH`) to break complex logic into named steps.

---

## 10) Example: step-by-step correlated subquery walk-through

Query:

```sql
SELECT c1.id, c1.name, c1.salary
FROM CUSTOMERS c1
WHERE c1.salary > (
  SELECT AVG(c2.salary)
  FROM CUSTOMERS c2
  WHERE c2.address = c1.address
);
```

Evaluation sketch:

-   For row `c1 = (id=1, address='Ahmedabad', salary=2000)`, DB computes:
    `AVG(c2.salary)` with `c2.address='Ahmedabad'` → say that returns `1800`.
    Compare `2000 > 1800` → TRUE → include row.
-   Repeat for every `c1` row.

---

## 11) Practical checklist (quick best practices)

-   If inner query does not use outer columns → non-correlated: run once.
-   If inner query uses outer columns → correlated: try rewriting to JOIN / window.
-   For existence checks, prefer `EXISTS`.
-   For membership on a small list, `IN` is fine; watch for `NULL`s.
-   Consider CTEs or derived tables to make nested logic readable.
-   Add indexes on correlated columns.
-   Test query plans (`EXPLAIN`) to see if DB rewrites subquery to join/semi-join.

---

## Summary

-   **Nested subquery** = subquery inside a subquery (multiple levels). If independent, it runs once (or at optimization time).
-   **Correlated subquery** = inner uses outer columns; conceptually evaluated per outer row but often optimized by the engine.
-   Prefer **joins**, **window functions**, or **lateral/apply** when they give simpler, faster plans.
-   Use **EXISTS** for existence checks, watch `NULL` behavior with `IN`, and inspect query plans when performance matters.
