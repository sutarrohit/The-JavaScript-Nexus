# ðŸ“˜ **SQL Indexes**

An **index** in SQL is a **performance optimization structure** used by databases to **speed up data retrieval**.
Itâ€™s similar to an index in a book â€” instead of scanning every page to find a word, you can jump directly to the page listed in the index.

### ðŸ” **How It Works**

-   A database **index** is typically implemented as a **balanced tree (B-Tree)** or **hash table**.
-   It stores **pointers (references)** to the rows of the table.
-   When you run a `SELECT` query with a `WHERE` condition, the database checks the index to quickly locate matching rows instead of scanning the entire table.

**Example:**

```sql
CREATE TABLE employees (
  emp_id INT PRIMARY KEY,
  emp_name VARCHAR(100),
  department VARCHAR(50),
  salary DECIMAL(10,2)
);
```

If you frequently query by `department`, you can create an index:

```sql
CREATE INDEX idx_department ON employees(department);
```

Now, this query will run faster:

```sql
SELECT * FROM employees WHERE department = 'HR';
```

Instead of checking every row, the database will use `idx_department` to directly find matching rows.

---

## âš™ï¸ **2. How an Index Works Internally**

### ðŸ“š **Without Index (Full Table Scan):**

The database checks **every row** one by one to find matches.
This is slow for large tables.

### âš¡ **With Index:**

The database uses the **index structure** (like a sorted list or B-Tree) to jump directly to relevant rows.

For example:

-   Table: 1 million rows
-   Searching `WHERE department = 'HR'`
-   Without index â†’ checks 1,000,000 rows
-   With index â†’ checks maybe 10â€“20 index entries

Indexes dramatically reduce I/O operations.

---

## ðŸ§± **3. Types of Indexes**

| Type                               | Description                                                                                                               | Example                                                          |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| **Primary Index**                  | Automatically created when a primary key is defined. Uniquely identifies each row.                                        | `PRIMARY KEY (emp_id)`                                           |
| **Unique Index**                   | Ensures all values in a column are unique.                                                                                | `CREATE UNIQUE INDEX idx_email ON users(email);`                 |
| **Single-Column Index**            | Index on one column only.                                                                                                 | `CREATE INDEX idx_salary ON employees(salary);`                  |
| **Composite Index (Multi-Column)** | Index on multiple columns. Useful for queries involving multiple conditions.                                              | `CREATE INDEX idx_dept_salary ON employees(department, salary);` |
| **Clustered Index**                | Sorts and stores the actual rows in the table according to the index key. A table can have only one clustered index.      | `PRIMARY KEY` usually creates it automatically.                  |
| **Non-Clustered Index**            | Creates a separate structure that stores column values and pointers to data rows. Multiple non-clustered indexes allowed. | `CREATE INDEX idx_name ON employees(emp_name);`                  |
| **Full-Text Index**                | Used for searching text data efficiently (e.g., search engines).                                                          | `CREATE FULLTEXT INDEX idx_content ON articles(content);`        |
| **Bitmap Index (in Oracle)**       | Uses bitmaps for columns with low distinct values (like gender or boolean fields).                                        | â€“                                                                |

---

## âš–ï¸ **4. Advantages and Disadvantages of Indexes**

### âœ… **Advantages**

-   Speeds up `SELECT` queries (data retrieval)
-   Helps in faster sorting and filtering (`ORDER BY`, `WHERE`)
-   Improves performance of `JOIN` operations
-   Enforces uniqueness when used with `UNIQUE` constraints

### âŒ **Disadvantages**

-   Slows down `INSERT`, `UPDATE`, and `DELETE`
    â†’ because the index also needs to be updated when data changes
-   Consumes **extra storage space**
-   Requires **maintenance** (periodic rebuilds, analysis)
-   Poorly chosen indexes can **hurt performance**

---

## ðŸ§© **5. Managing Indexes**

### ðŸ“Œ **Create an Index**

```sql
CREATE INDEX idx_customer_name ON customers(customer_name);
```

### ðŸ“Œ **Create a Unique Index**

```sql
CREATE UNIQUE INDEX idx_email_unique ON users(email);
```

### ðŸ“Œ **Drop an Index**

```sql
DROP INDEX idx_customer_name;
```

(_In MySQL, you use:_)

```sql
ALTER TABLE customers DROP INDEX idx_customer_name;
```

### ðŸ“Œ **Rebuild or Reorganize Index**

Over time, indexes become **fragmented** as data changes.

To fix it:

```sql
ALTER INDEX idx_customer_name REBUILD;
```

or

```sql
ALTER INDEX idx_customer_name REORGANIZE;
```

### ðŸ§  **Tips for Index Management**

-   Index **columns used frequently in WHERE, JOIN, and ORDER BY** clauses.
-   Avoid indexing columns with **frequent updates**.
-   Donâ€™t over-index (too many indexes = slower writes).
-   Regularly **monitor performance** using execution plans or statistics.

---

## ðŸš€ **6. Query Optimization with Indexes**

Indexes play a major role in **query optimization**.
The **query optimizer** uses them to choose the most efficient way to execute a query.

### âœ… **Best Practices**

1. **Use indexes for WHERE, JOIN, ORDER BY columns**

    ```sql
    SELECT * FROM orders WHERE customer_id = 100;
    ```

    ðŸ‘‰ Create an index on `customer_id`.

2. **Avoid SELECT \***
   â†’ Retrieve only needed columns to minimize I/O.

3. **Use Composite Indexes wisely**

    - Order of columns matters.
    - Example:

        ```sql
        CREATE INDEX idx_dept_salary ON employees(department, salary);
        ```

        Works for:

        ```sql
        WHERE department = 'HR' AND salary > 50000
        ```

        But **not** for:

        ```sql
        WHERE salary > 50000
        ```

        because `department` is the first column in the index.

4. **Analyze Query Execution Plan**
   Use:

    ```sql
    EXPLAIN SELECT * FROM employees WHERE department = 'HR';
    ```

    It shows whether the query uses the index.

5. **Update Statistics**
   Helps the optimizer make better decisions:

    ```sql
    ANALYZE TABLE employees;
    ```

6. **Avoid Functions on Indexed Columns**

    ```sql
    WHERE LOWER(name) = 'rohit'   -- âŒ index wonâ€™t be used
    WHERE name = 'Rohit'          -- âœ… index can be used
    ```

---

## ðŸ§® **7. Example Scenario**

### Table:

```sql
CREATE TABLE sales (
  sale_id INT PRIMARY KEY,
  customer_id INT,
  sale_date DATE,
  amount DECIMAL(10,2)
);
```

### Query:

```sql
SELECT * FROM sales WHERE customer_id = 10;
```

ðŸ‘‰ To optimize:

```sql
CREATE INDEX idx_customer_id ON sales(customer_id);
```

Now, if you run:

```sql
EXPLAIN SELECT * FROM sales WHERE customer_id = 10;
```

Youâ€™ll see the query uses `idx_customer_id`, drastically improving performance.

---

## ðŸ§  **8. Summary**

| Aspect          | Description                                       |
| --------------- | ------------------------------------------------- |
| **Purpose**     | Speed up data retrieval                           |
| **Storage**     | Stored separately from main table                 |
| **Downside**    | Slower data modification, more storage            |
| **Best Use**    | Columns frequently used in WHERE, JOIN, ORDER BY  |
| **Structure**   | Usually a B-Tree or Hash                          |
| **Maintenance** | Needs periodic rebuilding for optimal performance |

---

### ðŸ”¸ **In short:**

> Indexes = Fast SELECTs ðŸš€ but Slower INSERTs ðŸ¢
> Use them wisely to balance **read vs write performance**.
