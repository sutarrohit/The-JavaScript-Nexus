# Transaction Isolation Levels

Nice — let’s unpack transaction **isolation levels** carefully. I’ll explain what the common levels mean, the anomalies they allow or prevent, show short SQL transaction examples that demonstrate each anomaly, cover how DB engines implement isolation (locks vs MVCC), and finish with practical advice for real systems.

## 1) Why isolation levels matter

The **isolation** property decides how (and when) changes made by one transaction become visible to other concurrent transactions. Higher isolation gives stronger correctness guarantees but usually reduces concurrency and throughput. Choosing the right level is a trade-off between **consistency** and **performance**.

---

## 2) Key anomalies you need to know

These are the problems isolation levels try to avoid:

-   **Dirty read** — T2 reads data written by T1 that has _not yet committed_. If T1 later rolls back, T2 saw a value that never existed.
-   **Non-repeatable read** — T2 reads the same row twice inside its transaction and sees different values because T1 committed an update in between reads.
-   **Phantom read** — T2 runs the same query twice and sees new rows (or rows missing) inserted/removed by another committed transaction.
-   **Lost update** — Two transactions read the same row and both write updates; one update overwrites the other without considering the concurrent change.
-   **Write skew / serialization anomalies** — More subtle inconsistent states that can happen under snapshot isolation (e.g., two concurrent transactions each read a value and write complementary changes that together violate a constraint).

---

## 3) The four standard isolation levels (what they allow / prevent)

> **Short checklist** (SQL standard behavior):

-   **Read Uncommitted** — allows **dirty reads**, non-repeatable reads, phantoms (no protection).
-   **Read Committed** — prevents **dirty reads**; allows non-repeatable reads and phantoms.
-   **Repeatable Read** — prevents dirty & non-repeatable reads; **may still allow phantoms** under the SQL standard (implementation-dependent).
-   **Serializable** — strongest: prevents dirty, non-repeatable, phantom, and other anomalies — transactions behave as if executed in some serial order.

Now more detail and examples for each.

---

### A. READ UNCOMMITTED

**Meaning:** A transaction may see uncommitted writes from other transactions.

**Anomalies allowed:** Dirty reads, non-repeatable reads, phantoms, lost updates — basically everything.

**Example (dirty read):**

```sql
T1: BEGIN;
T1: UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- not yet committed

T2: BEGIN;
T2: SELECT balance FROM accounts WHERE id = 1;  -- reads the uncommitted value from T1 (dirty read)

T1: ROLLBACK;  -- undo
T2: sees data that never existed
```

**When used:** Rarely useful in OLTP systems. Only in special analytic or debug scenarios where absolute freshness / correctness is unimportant.

---

### B. READ COMMITTED (common default)

**Meaning:** A transaction only sees data committed by other transactions. Reads always reflect the latest committed state at the time of the read.

**Anomalies prevented:** **Dirty reads prevented.**
**Anomalies allowed:** Non-repeatable reads and phantoms.

**Example (non-repeatable read):**

```sql
T1: BEGIN;
T1: SELECT qty FROM inventory WHERE item = 'A';  -- returns 10

T2: BEGIN;
T2: UPDATE inventory SET qty = 5 WHERE item = 'A';
T2: COMMIT;

T1: SELECT qty FROM inventory WHERE item = 'A';  -- now returns 5 (non-repeatable)
```

**Behavior note:** In Read Committed, every SELECT sees the most recently committed value at the time of that SELECT.

**When used:** Good balance for many OLTP workloads — avoids dirty reads, allows higher concurrency than stricter levels.

---

### C. REPEATABLE READ

**Meaning (SQL standard):** Once a transaction reads a row, subsequent reads of the _same row_ will return the same value for the duration of the transaction. The standard still allows phantom rows (i.e., set of rows matching a predicate may change).
**Important:** **Implementations vary.** Many DB engines implement Repeatable Read as a _snapshot_ of the DB at transaction start (snapshot isolation), which also avoids certain phantom behaviors — but snapshot isolation is **not necessarily serializable** and can allow anomalies like **write-skew**.

**Anomalies prevented:** Dirty reads and non-repeatable reads prevented.
**Anomalies allowed:** Possibly phantoms and some write-skew anomalies (depends on implementation).

**Example (phantom possible under SQL standard):**

```sql
T1: BEGIN;
T1: SELECT * FROM orders WHERE amount > 100;  -- returns 2 rows

T2: BEGIN;
T2: INSERT INTO orders (id, amount) VALUES (99, 150);
T2: COMMIT;

T1: SELECT * FROM orders WHERE amount > 100;  -- under some implementations this may see the new row (phantom)
```

**When used:** When your transaction must read stable values for rows it touches (e.g., repeated reads must match). Common for analytical reads that should be stable during transaction.

---

### D. SERIALIZABLE (strongest)

**Meaning:** Transactions behave as if they ran one after another in some serial order. Prevents all the anomalies above, including phantoms and write-skew. This is the strictest (and most expensive) isolation.

**How it enforces:** Implementations either:

-   Acquire locks to ensure serial execution (locking approach), **or**
-   Use **Serializable Snapshot Isolation** (SSI) and detect dangerous patterns and abort one of the conflicting transactions (PostgreSQL uses SSI).

**Example (prevents write skew):**

```sql
Context: Two doctors must not both go off call: a table doctors(on_call boolean)

T1: BEGIN (serializable)
T1: SELECT on_call FROM doctors WHERE id = 1;  -- true
T1: IF true THEN UPDATE doctors SET on_call = false WHERE id = 1;

T2: BEGIN (serializable)
T2: SELECT on_call FROM doctors WHERE id = 2;  -- true
T2: IF true THEN UPDATE doctors SET on_call = false WHERE id = 2;

Both try to set their own on_call false -> could leave nobody on call (write-skew).
Under SERIALIZABLE one of the transactions will be aborted or blocked so the invariant is preserved.
```

**When used:** For critical correctness (banking transfers, accounting, strict invariants). Use with caution — expect increased contention, blocking, and possible transaction retries.

---

## 4) How DB engines implement isolation (locks vs MVCC)

-   **Locking (pessimistic concurrency)**: e.g., some SQL Server modes use locks — reads may block writers and vice versa depending on locks. Serializable may translate into range locks to prevent phantoms.
-   **MVCC (Multi-Version Concurrency Control)**: e.g., PostgreSQL, many MySQL/InnoDB modes: readers don’t block writers. Each transaction reads a snapshot (a consistent view) of the DB. Serializable under MVCC often uses _detection + abort_ (e.g., Serializable Snapshot Isolation) rather than strict mutual exclusion.

**Practical consequence:** Under MVCC, serializable transactions can be aborted (you must retry). Under locking, they may block and cause waits/deadlocks.

---

## 5) How to set isolation level (typical SQL syntax)

**Per-transaction (standard):**

```sql
-- Start a transaction at a specific isolation level
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- or
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;  -- must be before any query in the transaction
BEGIN;
```

**Session-wide (examples):**

-   PostgreSQL:

```sql
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- or
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- for current transaction only
```

-   MySQL:

```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- or for current tx:
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
```

-   SQL Server:

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRAN;
```

_(Exact commands vary slightly between DBMS — set the isolation before starting work in that transaction.)_

---

## 6) Practical tips & best practices

-   **Default is often Read Committed** (Postgres) or **Repeatable Read** (MySQL/InnoDB). Know your DB’s default.
-   **Keep transactions short.** Long transactions increase the chance of conflicts and resource retention.
-   For operations that update rows based on prior reads, use **SELECT ... FOR UPDATE** (or `FOR SHARE`) to lock the rows you intend to change and avoid lost-updates:

    ```sql
    BEGIN;
    SELECT qty FROM inventory WHERE id=1 FOR UPDATE;
    UPDATE inventory SET qty = qty - 1 WHERE id=1;
    COMMIT;
    ```

-   When you need serializability but want to avoid heavy locking, use **Serializable (MVCC/SSI)** and **retry** transactions on abort — design for retries.
-   For optimistic concurrency control, add a `version` or `updated_at` column and `UPDATE ... WHERE version = :v` — retry if affected rows = 0.
-   **Analytics / reporting**: snapshot isolation or Repeatable Read is often good — you get a stable read without blocking writers.
-   **Banking / financial invariants**: prefer Serializable or strong application-level checks + up-front locking.

---

## 7) Cheat-sheet table (SQL standard view)

| Isolation level  | Dirty reads | Non-repeatable reads | Phantoms  |
| ---------------- | ----------- | -------------------- | --------- |
| Read Uncommitted | yes         | yes                  | yes       |
| Read Committed   | no          | yes                  | yes       |
| Repeatable Read  | no          | no                   | **maybe** |
| Serializable     | no          | no                   | no        |

> **Note:** The “maybe” for Repeatable Read means _SQL standard_ allows phantoms; many DBs’ implementations (snapshot isolation, next-key locks in InnoDB) provide stronger guarantees. Always check your DB’s docs for exact behavior.

---

## 8) When to pick which level (short guidance)

-   **Performance-critical reads, many concurrent writes**: Read Committed.
-   **Need repeatable reads inside txn (stable reads) but not full serializability**: Repeatable Read or snapshot isolation.
-   **Strong correctness and invariants (money transfers, accounting)**: Serializable (or careful application logic + locking).
-   **Prevent lost updates on update-after-read patterns**: use `SELECT ... FOR UPDATE` or optimistic version checks.

---

## 9) Final notes

-   **Isolation levels are a trade-off.** Higher isolation gives stronger correctness but lowers concurrency and can increase aborts or waits.
-   **Implementations differ.** MySQL (InnoDB), PostgreSQL, SQL Server, Oracle all have subtle differences — especially how they implement Repeatable Read and Serializable. If you face a bug or weird behavior, check your DB vendor documentation and run a small reproducible test.
-   **Design for retries** if you use Serializable under MVCC (you’ll sometimes get `serialization_failure` and must retry the transaction).
