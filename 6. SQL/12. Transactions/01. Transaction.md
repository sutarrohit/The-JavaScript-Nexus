## üîπ **1. What is a Transaction?**

A **Transaction** in SQL is a **logical unit of work** that contains one or more SQL statements (like `INSERT`, `UPDATE`, `DELETE`, etc.) that must be executed as a single unit.

If any part of the transaction fails, **the entire transaction is rolled back**, ensuring that the database remains consistent.

In short:

> A transaction is ‚Äú**all-or-nothing**.‚Äù Either all operations succeed, or none are applied.

### ‚úÖ **Example of a Transaction**

```sql
BEGIN;  -- Start transaction

UPDATE accounts SET balance = balance - 500 WHERE account_id = 1;  -- Withdraw money
UPDATE accounts SET balance = balance + 500 WHERE account_id = 2;  -- Deposit money

COMMIT;  -- Make all changes permanent
```

If one of these queries fails (say, the second one), we can use:

```sql
ROLLBACK;
```

This will undo all previous changes made during this transaction.

---

### üí° **Why Use Transactions?**

Transactions are vital when:

-   Transferring money between accounts (banking systems)
-   Booking tickets or hotel rooms
-   Making purchases in e-commerce systems

They prevent **partial updates** that could corrupt your data.

---

## üîπ **2. ACID Properties**

The reliability of transactions in databases is based on the **ACID** principle.

ACID stands for:
**A ‚Äì Atomicity**
**C ‚Äì Consistency**
**I ‚Äì Isolation**
**D ‚Äì Durability**

Let‚Äôs understand each one in depth üëá

---

### üß± **A ‚Äì Atomicity (All or Nothing)**

-   Ensures that **either all statements in a transaction are executed successfully** or **none of them are**.
-   If one operation fails, the transaction **rolls back** all previous operations.

**Example:**

```sql
BEGIN;

UPDATE accounts SET balance = balance - 1000 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 1000 WHERE account_id = 2;

COMMIT;
```

If the second update fails (say, `account_id = 2` doesn‚Äôt exist), the first update is **reversed**.
‚û° No partial transfer occurs.

---

### ‚öñÔ∏è **C ‚Äì Consistency (Valid State)**

-   Ensures that a transaction **brings the database from one valid state to another valid state**.
-   Data must always satisfy **all integrity constraints**, such as primary keys, foreign keys, and check constraints.

**Example:**
If an account balance should never go negative, and an update would cause it to, the database rejects the transaction ‚Äî maintaining consistency.

---

### üö¶ **I ‚Äì Isolation (No Interference)**

-   Ensures that **concurrent transactions** do not affect each other.
-   Each transaction acts as if it‚Äôs the **only one** executing at that moment.
-   This avoids problems like:

    -   **Dirty Reads** (reading uncommitted data)
    -   **Non-repeatable Reads** (data changes between reads)
    -   **Phantom Reads** (new rows appear during re-read)

**Example:**
If two users try to transfer money at the same time, isolation ensures their actions don‚Äôt overlap or corrupt balances.

Databases achieve this via **isolation levels**, like:

1. READ UNCOMMITTED
2. READ COMMITTED
3. REPEATABLE READ
4. SERIALIZABLE

Higher levels = stronger isolation (but less performance).

---

### üíæ **D ‚Äì Durability (Permanent Changes)**

-   Once a transaction is **committed**, the changes are **permanent** ‚Äî even if the system crashes.
-   The database uses **logs and backups** (like Write-Ahead Logging in PostgreSQL) to recover committed data after failure.

**Example:**
If a system crashes right after a successful `COMMIT`, once it restarts, your data will still be there ‚Äî not lost.

---

## üß© **How Transactions and ACID Work Together**

| Concept         | Description                                                 | Example                            |
| --------------- | ----------------------------------------------------------- | ---------------------------------- |
| **Transaction** | A group of SQL operations executed as a single logical unit | Transfer ‚Çπ500 between accounts     |
| **Atomicity**   | All operations complete or none                             | If one update fails, rollback both |
| **Consistency** | Database remains valid before and after                     | Total balance before = total after |
| **Isolation**   | Transactions don‚Äôt interfere                                | Two transfers can occur safely     |
| **Durability**  | Changes persist even after crash                            | After commit, data is not lost     |

---

## üß† **Visualization**

```
Transaction (T1)
-----------------------------
| BEGIN TRANSACTION         |
| Update Account A          |
| Update Account B          |
| COMMIT or ROLLBACK        |
-----------------------------

          ‚Üì  ACID Ensures ‚Üì

Atomicity ‚Üí All or None
Consistency ‚Üí Data stays valid
Isolation ‚Üí No interference
Durability ‚Üí Changes are permanent
```

---

## ‚öôÔ∏è **Common SQL Commands for Transactions**

| Command                       | Description                           |
| ----------------------------- | ------------------------------------- |
| `BEGIN` / `START TRANSACTION` | Start a transaction                   |
| `COMMIT`                      | Save all changes                      |
| `ROLLBACK`                    | Undo all changes since last `BEGIN`   |
| `SAVEPOINT`                   | Set a checkpoint inside a transaction |
| `ROLLBACK TO SAVEPOINT`       | Undo only to a specific savepoint     |

**Example with SAVEPOINT:**

```sql
BEGIN;
UPDATE accounts SET balance = balance - 500 WHERE id = 1;
SAVEPOINT before_deposit;
UPDATE accounts SET balance = balance + 500 WHERE id = 2;

-- If error occurs
ROLLBACK TO before_deposit;

COMMIT;
```
