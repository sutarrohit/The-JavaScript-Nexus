# **Recursive Types in TypeScript**

**Recursive types** in TypeScript are types that refer to themselves, allowing you to define **nested structures** such as trees, linked lists, and deeply nested objects. These are useful when working with **hierarchical data** like JSON structures, file systems, or abstract syntax trees.

---

## **1Ô∏è‚É£ Basic Concept of Recursive Types**

A **recursive type** is a type that includes itself in its definition.

### **‚úÖ Example: A Simple Recursive Type (Nested Object)**

```ts
type NestedObject = {
  value: string;
  child?: NestedObject; // Recursive reference
};

const obj: NestedObject = {
  value: "root",
  child: {
    value: "child",
    child: {
      value: "grandchild",
    },
  },
};
```

‚úÖ Here, `NestedObject` refers to itself, allowing **nested** structures.

---

## **2Ô∏è‚É£ Real-World Examples of Recursive Types**

### **‚úÖ Example: Tree Structure (Recursive Data Type)**

A **tree** is a common data structure where each node has children, making it **recursive**.

```ts
type TreeNode<T> = {
  value: T;
  children?: TreeNode<T>[]; // Array of TreeNode, making it recursive
};

const tree: TreeNode<number> = {
  value: 1,
  children: [
    {
      value: 2,
      children: [{ value: 4 }, { value: 5 }],
    },
    {
      value: 3,
    },
  ],
};
```

‚úÖ `TreeNode<T>` allows **nested tree-like structures**, where each node can have multiple children.

---

### **‚úÖ Example: Linked List (Recursive Type)**

A **linked list** is a data structure where each node points to the next node, making it **recursive**.

```ts
type LinkedList<T> = {
  value: T;
  next?: LinkedList<T>; // Recursive reference
};

const list: LinkedList<number> = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
    },
  },
};
```

‚úÖ `LinkedList<T>` recursively references itself to create a **chain of nodes**.

---

### **‚úÖ Example: JSON-like Nested Object**

Recursive types are useful for handling **nested JSON-like structures**.

```ts
type JSONValue = string | number | boolean | null | JSONObject | JSONArray;
type JSONObject = { [key: string]: JSONValue };
type JSONArray = JSONValue[];

const jsonData: JSONObject = {
  name: "Alice",
  age: 25,
  address: {
    city: "New York",
    zip: 10001,
  },
  hobbies: ["reading", "gaming"],
};
```

‚úÖ `JSONValue` is a **recursive type** that can represent any **valid JSON** structure.

---

## **3Ô∏è‚É£ Handling Recursive Types with TypeScript Utility Types**

### **‚úÖ Example: Deep Partial (Making Nested Properties Optional)**

You can use **recursive types** to create a `DeepPartial<T>` type, which makes all nested properties optional.

```ts
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type User = {
  name: string;
  address: {
    city: string;
    zip: number;
  };
};

const partialUser: DeepPartial<User> = {
  address: {
    city: "Mumbai",
  },
};
```

‚úÖ `DeepPartial<T>` makes all properties and **deeply nested properties** optional.

---

### **‚úÖ Example: Deep Readonly (Making All Properties Immutable)**

```ts
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

const user: DeepReadonly<User> = {
  name: "Alice",
  address: { city: "NY", zip: 10001 },
};

// user.address.city = "LA"; // ‚ùå Error: Cannot assign to 'city' because it is a read-only property
```

‚úÖ `DeepReadonly<T>` makes **all properties and nested properties** immutable.

---

## **4Ô∏è‚É£ Handling Recursive Types with Generics**

You can use **generics** with recursive types to make them **more flexible**.

### **‚úÖ Example: Generic Tree Structure**

```ts
type Tree<T> = {
  value: T;
  children?: Tree<T>[];
};

const numTree: Tree<number> = {
  value: 10,
  children: [{ value: 20 }, { value: 30 }],
};
const strTree: Tree<string> = {
  value: "root",
  children: [{ value: "child1" }],
};
```

‚úÖ `Tree<T>` allows **different types of data** in the tree.

---

## **üöÄ Key Takeaways**

‚úÖ **Recursive types allow self-referencing types for nested structures.**  
‚úÖ **Useful for trees, linked lists, and JSON-like objects.**  
‚úÖ **Can be combined with TypeScript utilities like `DeepPartial<T>`.**  
‚úÖ **Works well with generics for reusable type structures.**
