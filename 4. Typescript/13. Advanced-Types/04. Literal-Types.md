# **Literal Types in TypeScript**

**Literal Types** in TypeScript allow you to specify exact values that a variable, function parameter, or return type can take. This makes your code more precise and reduces potential errors.

---

## **1Ô∏è‚É£ What Are Literal Types?**

A **literal type** is a type that represents a specific value, rather than a broad type like `string` or `number`.

### **Example: String Literal Type**

```ts
let color: "red"; // color can only be "red"
color = "red"; // ‚úÖ Allowed
color = "blue"; // ‚ùå Error: Type '"blue"' is not assignable to type '"red"'.
```

‚úÖ `color` can **only** hold the value `"red"`.

---

## **2Ô∏è‚É£ Types of Literal Types**

### **‚úÖ String Literal Types**

```ts
type Direction = "up" | "down" | "left" | "right";

let move: Direction;
move = "up"; // ‚úÖ Allowed
move = "right"; // ‚úÖ Allowed
move = "jump"; // ‚ùå Error: Type '"jump"' is not assignable to type 'Direction'.
```

‚úÖ `Direction` is restricted to only four specific string values.

---

### **‚úÖ Number Literal Types**

```ts
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;

let roll: DiceRoll;
roll = 3; // ‚úÖ Allowed
roll = 7; // ‚ùå Error: Type '7' is not assignable to type 'DiceRoll'.
```

‚úÖ `DiceRoll` can only be values from `1` to `6`.

---

### **‚úÖ Boolean Literal Types**

```ts
type Answer = true | false;

let isCorrect: Answer;
isCorrect = true; // ‚úÖ Allowed
isCorrect = false; // ‚úÖ Allowed
isCorrect = "yes"; // ‚ùå Error: Type '"yes"' is not assignable to type 'Answer'.
```

‚úÖ `isCorrect` can **only** be `true` or `false`.

---

## **3Ô∏è‚É£ Using Literal Types with Functions**

You can use **literal types** in function parameters and return types.

### **‚úÖ Example: Function with Literal Type Parameters**

```ts
function respond(answer: "yes" | "no"): string {
  return `You said: ${answer}`;
}

console.log(respond("yes")); // ‚úÖ "You said: yes"
console.log(respond("maybe")); // ‚ùå Error: Argument of type '"maybe"' is not assignable to parameter of type '"yes" | "no"'.
```

‚úÖ This function only accepts `"yes"` or `"no"` as arguments.

---

## **4Ô∏è‚É£ Literal Types with Type Aliases**

Literal types work well with **type aliases** for better readability.

```ts
type Status = "success" | "error" | "pending";

let currentStatus: Status;
currentStatus = "success"; // ‚úÖ Allowed
currentStatus = "failed"; // ‚ùå Error: Type '"failed"' is not assignable to type 'Status'.
```

‚úÖ This makes the code **more maintainable**.

---

## **5Ô∏è‚É£ Combining Literal Types with Unions**

Literal types are often combined with **union types** to define multiple possible values.

```ts
type TrafficLight = "red" | "yellow" | "green";

function changeLight(light: TrafficLight): string {
  return `Light changed to: ${light}`;
}

console.log(changeLight("green")); // ‚úÖ Allowed
console.log(changeLight("blue")); // ‚ùå Error
```

‚úÖ `changeLight` ensures only valid traffic light colors are used.

---

## **6Ô∏è‚É£ Literal Types and Type Narrowing**

TypeScript **infers** literal types automatically when you use `const`.

```ts
const x = "hello"; // Type is "hello"
let y = "hello"; // Type is string

x = "world"; // ‚ùå Error: Type '"world"' is not assignable to type '"hello"'.
y = "world"; // ‚úÖ Allowed
```

‚úÖ `const` variables get **literal types**, while `let` variables get **broader types**.

---

## **7Ô∏è‚É£ Literal Types in Discriminated Unions**

Discriminated unions use **literal types** for type safety.

```ts
type SuccessResponse = {
  status: "success";
  data: string;
};

type ErrorResponse = {
  status: "error";
  message: string;
};

type Response = SuccessResponse | ErrorResponse;

function handleResponse(response: Response) {
  if (response.status === "success") {
    console.log("Data:", response.data);
  } else {
    console.log("Error:", response.message);
  }
}

handleResponse({ status: "success", data: "Hello" }); // ‚úÖ Allowed
handleResponse({ status: "error", message: "Something went wrong" }); // ‚úÖ Allowed
handleResponse({ status: "failed", message: "Invalid" }); // ‚ùå Error
```

‚úÖ Ensures only `"success"` or `"error"` are valid `status` values.

---

## **üöÄ Key Takeaways**

‚úÖ **Literal types restrict variables to specific values, making code safer.**  
‚úÖ **They can be strings, numbers, or booleans.**  
‚úÖ **Useful in function parameters, return types, and type aliases.**  
‚úÖ **Combine with union types for better flexibility.**  
‚úÖ **Works great for discriminated unions and type narrowing.**
