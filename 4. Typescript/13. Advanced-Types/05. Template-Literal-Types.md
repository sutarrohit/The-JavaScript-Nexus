# **Template Literal Types in TypeScript**

**Template Literal Types** in TypeScript allow you to create **dynamic string-based types** by using string literal types combined with **template literals** (similar to JavaScript template literals: `` `${}` ``).

They enable powerful **type transformations** and **string manipulation** at the type level.

---

## **1Ô∏è‚É£ Basic Syntax of Template Literal Types**

Template literal types are defined using **backticks** (`` ` ` ``) and allow **interpolation of types** inside the placeholders `${}`.

### **‚úÖ Example: Simple Template Literal Type**

```ts
type Greeting = `Hello, ${string}!`;

let greet1: Greeting = "Hello, John!"; // ‚úÖ Allowed
let greet2: Greeting = "Hello, Alice!"; // ‚úÖ Allowed
let greet3: Greeting = "Hi, John!"; // ‚ùå Error: Does not match `Hello, ${string}!`
```

‚úÖ The type enforces that all valid values must start with `"Hello, "` followed by any string and an exclamation mark.

---

## **2Ô∏è‚É£ Combining Template Literal Types with Union Types**

Template literal types work well with **union types** to create **dynamic type combinations**.

### **‚úÖ Example: Creating Dynamic Variants**

```ts
type Size = "small" | "medium" | "large";
type ShirtSize = `shirt-${Size}`;

let size1: ShirtSize = "shirt-small"; // ‚úÖ Allowed
let size2: ShirtSize = "shirt-large"; // ‚úÖ Allowed
let size3: ShirtSize = "tshirt-medium"; // ‚ùå Error: Does not match `shirt-${Size}`
```

‚úÖ Ensures that only predefined values (`shirt-small`, `shirt-medium`, `shirt-large`) are valid.

---

## **3Ô∏è‚É£ Inferring Dynamic String Types**

Template literal types can be used with the `infer` keyword inside conditional types to **extract** specific parts of a string.

### **‚úÖ Example: Extract Prefix and Suffix**

```ts
type ExtractSuffix<T> = T extends `shirt-${infer S}` ? S : never;

type SmallSize = ExtractSuffix<"shirt-small">; // "small"
type LargeSize = ExtractSuffix<"shirt-large">; // "large"
type InvalidSize = ExtractSuffix<"pants-medium">; // never
```

‚úÖ If the string starts with `"shirt-"`, it extracts the remaining part.

---

## **4Ô∏è‚É£ Creating Dynamic Paths and Identifiers**

Template literal types are useful for defining **API routes, CSS class names, and database IDs**.

### **‚úÖ Example: API Routes**

```ts
type Route = `/api/${"users" | "posts" | "comments"}`;

let validRoute1: Route = "/api/users"; // ‚úÖ Allowed
let validRoute2: Route = "/api/posts"; // ‚úÖ Allowed
let invalidRoute: Route = "/api/products"; // ‚ùå Error: Not in union
```

‚úÖ Ensures that only `/api/users`, `/api/posts`, or `/api/comments` are valid.

---

## **5Ô∏è‚É£ String Transformation with Built-in TypeScript Utility Types**

TypeScript provides **utility types** that work with **template literals** to transform strings.

### **‚úÖ Example: Capitalize and Lowercase**

```ts
type Capitalized = Capitalize<"hello world">; // "Hello world"
type Lowercased = Lowercase<"HELLO">; // "hello"
type Uppercased = Uppercase<"typescript">; // "TYPESCRIPT"
type Uncapitalized = Uncapitalize<"Hello">; // "hello"
```

‚úÖ These utility types help in manipulating string formats.

---

## **6Ô∏è‚É£ Advanced Use Cases of Template Literal Types**

### **‚úÖ Example: Generating CSS Class Names**

```ts
type Variant = "primary" | "secondary" | "danger";
type Size = "small" | "medium" | "large";

type ButtonClass = `btn-${Variant}-${Size}`;

let btn1: ButtonClass = "btn-primary-small"; // ‚úÖ Allowed
let btn2: ButtonClass = "btn-secondary-large"; // ‚úÖ Allowed
let btn3: ButtonClass = "btn-warning-medium"; // ‚ùå Error: "warning" is not a valid variant
```

‚úÖ Ensures only predefined class names are valid.

---

### **‚úÖ Example: Generating Database Table Names**

```ts
type Table = "users" | "orders" | "products";
type Column = "id" | "name" | "created_at";

type ColumnName = `${Table}_${Column}`;

let col1: ColumnName = "users_id"; // ‚úÖ Allowed
let col2: ColumnName = "orders_name"; // ‚úÖ Allowed
let col3: ColumnName = "cart_total"; // ‚ùå Error: "cart" is not a valid table
```

‚úÖ Ensures column names follow a strict naming pattern.

---

## **üöÄ Key Takeaways**

‚úÖ **Template Literal Types allow dynamic type generation using string interpolation.**  
‚úÖ **They work well with union types, conditional types, and utility types.**  
‚úÖ **Useful for defining dynamic routes, class names, and database identifiers.**  
‚úÖ **Improve type safety by enforcing strict naming patterns.**
