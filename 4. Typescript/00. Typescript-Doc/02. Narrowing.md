# Narrowing in TypeScript

## 1. What is Narrowing?

-   **Definition**: Narrowing is the process of refining a variable’s type from a **broader union type** to a **more specific type**, based on runtime checks and control flow.
-   TypeScript performs **control flow analysis** to determine the most specific type possible at each point in code.
-   Narrowing happens when TypeScript recognizes a **type guard** or other control-flow construct.

---

## 2. Example: `padLeft`

```ts
function padLeft(padding: number | string, input: string): string {
    if (typeof padding === "number") {
        return " ".repeat(padding) + input;
    }
    return padding + input;
}
```

-   If `padding` is a **number**, we prepend spaces.
-   If `padding` is a **string**, we concatenate it directly.
-   `typeof` is a **type guard** that tells TypeScript which branch of the union type applies.

---

## 3. Narrowing Constructs

### (a) `typeof` Type Guards

-   Recognized return values: `"string"`, `"number"`, `"bigint"`, `"boolean"`, `"symbol"`, `"undefined"`, `"object"`, `"function"`.
-   Example:

```ts
function printAll(strs: string | string[] | null) {
    if (typeof strs === "object") {
        // strs: string[] | null
    } else if (typeof strs === "string") {
        // strs: string
    }
}
```

⚠️ Caveat: `typeof null === "object"` → requires extra care.

---

### (b) Truthiness Narrowing

-   JavaScript conditions coerce values to boolean (`if`, `&&`, `||`, `!`).
-   Falsy values: `0`, `NaN`, `""`, `0n`, `null`, `undefined`.
-   Example:

```ts
function getUsersOnlineMessage(numUsersOnline: number) {
    if (numUsersOnline) return `There are ${numUsersOnline} online now!`;
    return "Nobody's here. :(";
}
```

⚠️ Pitfall: Wrapping everything in `if (strs)` hides cases like empty string `""`.

---

### (c) Equality Narrowing

-   `===`, `!==`, `==`, `!=` refine types.

```ts
function example(x: string | number, y: string | boolean) {
    if (x === y) {
        // x, y are strings
    }
}
```

-   Loose equality (`== null`) checks **both `null` and `undefined`**.

---

### (d) `in` Operator Narrowing

-   Narrows based on property existence.

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
    if ("swim" in animal) {
        animal.swim();
    } else {
        animal.fly();
    }
}
```

---

### (e) `instanceof` Narrowing

-   Narrows by checking prototype chain.

```ts
function logValue(x: Date | string) {
    if (x instanceof Date) {
        console.log(x.toUTCString()); // x: Date
    } else {
        console.log(x.toUpperCase()); // x: string
    }
}
```

---

### (f) Assignments

-   TypeScript narrows variables after assignment based on values.

```ts
let x: string | number | boolean;
x = Math.random() < 0.5; // x: boolean
x = "hello"; // x: string
x = 100; // x: number
```

---

### (g) Control Flow Analysis

-   TypeScript tracks reachability to refine types.

```ts
function padLeft(padding: number | string, input: string) {
    if (typeof padding === "number") {
        return " ".repeat(padding) + input; // padding: number
    }
    return padding + input; // padding: string
}
```

---

## 4. User-Defined Type Guards (Type Predicates)

-   Custom narrowing using functions.

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}

let pet = getSmallPet();
if (isFish(pet)) {
    pet.swim(); // narrowed to Fish
} else {
    pet.fly(); // narrowed to Bird
}
```

-   Useful with array filters:

```ts
const fishes: Fish[] = zoo.filter(isFish);
```

---

## 5. Assertion Functions

-   Functions that throw errors when narrowing fails.
-   Syntax: `asserts paramName is Type`.

---

## 6. Discriminated Unions

-   A powerful narrowing pattern using a **common discriminant property**.

```ts
interface Circle {
    kind: "circle";
    radius: number;
}
interface Square {
    kind: "square";
    sideLength: number;
}
type Shape = Circle | Square;
```

-   Example:

```ts
function getArea(shape: Shape) {
    switch (shape.kind) {
        case "circle":
            return Math.PI * shape.radius ** 2;
        case "square":
            return shape.sideLength ** 2;
    }
}
```

-   **Advantages**:

    -   Eliminates need for `!` non-null assertions.
    -   Compiler checks for exhaustiveness.

---

## 7. The `never` Type & Exhaustiveness Checking

-   `never` represents impossible states.
-   Used to ensure **all union members are handled**.

```ts
function getArea(shape: Shape) {
    switch (shape.kind) {
        case "circle":
            return Math.PI * shape.radius ** 2;
        case "square":
            return shape.sideLength ** 2;
        default:
            const _exhaustiveCheck: never = shape; // Error if unhandled case
            return _exhaustiveCheck;
    }
}
```

---

## 8. Key Takeaways

1. **Narrowing** refines union types based on runtime logic.
2. Tools for narrowing:

    - `typeof`
    - truthiness
    - equality checks
    - `in`
    - `instanceof`
    - control flow analysis
    - assignments
    - user-defined type guards
    - discriminated unions

3. **Discriminated unions + `never`** → best practice for exhaustive and safe handling.
4. TypeScript mirrors **real JS runtime behavior** while adding type safety.
