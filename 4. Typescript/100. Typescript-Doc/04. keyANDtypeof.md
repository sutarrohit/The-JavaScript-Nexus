# 1. What `keyof` does (in one line)

`keyof T` produces a union of the _property keys_ of object type `T`. Those keys can be `string` literals, `number` literals, or `symbol`s.

```ts
type Point = { x: number; y: number };
type P = keyof Point; // "x" | "y"
```

---

## 1) Index signatures & key coercion

If a type has an index signature, `keyof` reflects that:

```ts
type Arrayish = { [n: number]: unknown };
type A = keyof Arrayish; // number

type Mapish = { [k: string]: boolean };
type M = keyof Mapish; // string | number  (because obj[0] === obj["0"])
```

### Why `string | number`?

In JS, property access like `obj[0]` coerces to `"0"`. So a `string` index signature also accepts numeric-looking keys, hence the union.

### Symbols too

If you use a `symbol` index signature:

```ts
type SymbolMap = { [s: symbol]: number };
type KS = keyof SymbolMap; // symbol
```

---

## 2) Optional & readonly don‚Äôt change the keys

`keyof` doesn‚Äôt care whether a property is optional or readonly; it only cares about _names_.

```ts
type Opt = { a?: string; readonly b: number };
type K = keyof Opt; // "a" | "b"
```

---

## 3) Classes and `keyof`

For a class type, `keyof` yields the _public instance_ members‚Äô names (methods included).

```ts
class User {
    public id = 0;
    protected secret = "shh";
    private token = "x";
    isAdmin() {
        return false;
    }
}

type KU = keyof User; // "id" | "isAdmin"
```

---

## 4) Arrays, tuples, and `keyof`

### Arrays

```ts
type SArr = string[];
type KA = keyof SArr; // number | "length" | "toString" | "pop" | ... (array members)
```

Arrays have numeric indices (`number`) plus many method names and `"length"`.

### Tuples

Tuples are fixed-length arrays; their numeric keys are _literals_:

```ts
type T = [string, number];
type KT = keyof T; // "0" | "1" | "length" | "toString" | ...
```

This is useful when you want to index into tuples by exact positions.

---

## 5) `keyof` with unions & intersections

These two are easy to mix up:

### Intersections (`&`): keys **combine (union)**

```ts
type A = { a: string };
type B = { b: number };
type K1 = keyof (A & B); // "a" | "b"
```

### Unions (`|`): `keyof` **distributes** (results in union of keys)

```ts
type C = { c: boolean };
type D = { d: Date };
type K2 = keyof (C | D); // "c" | "d"
```

> Practical caveat: with a union object type, you can‚Äôt safely access `obj[key]` unless you‚Äôve narrowed to the member that definitely has that key. Even though `keyof (C | D)` is `"c" | "d"`, trying to read `obj["c"]` is unsafe if `obj` might be `{ d: Date }`.

---

## 6) `keyof` with `typeof` (very common)

Use `typeof` on _values_ to turn them into types, then `keyof` to get literal key unions.

```ts
const STATUS = {
    draft: 0,
    published: 1,
    archived: 2
} as const;

type StatusKey = keyof typeof STATUS; // "draft" | "published" | "archived"
```

This pattern is everywhere‚Äîgreat for constraining API params, command names, etc.

---

## 7) Enums and `keyof typeof`

```ts
enum Direction {
    Up,
    Down,
    Left,
    Right
}

type DirName = keyof typeof Direction;
// "Up" | "Down" | "Left" | "Right"
```

> Note: `keyof typeof Enum` gives you the _names_ of the enum members, not their numeric values.

---

## 8) `keyof any`, `keyof never`

-   `keyof any` is `string | number | symbol` (the three possible key types).
-   `keyof never` is `never` (no keys).

These show up in generic constraints and conditional types.

---

## 9) With mapped & utility types (where `keyof` shines)

`keyof` becomes powerful when combined with generics and mapped types:

### Safe property accessor

```ts
function get<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key]; // type-safe
}
```

### Core utilities built on `keyof`

-   `Pick<T, K extends keyof T>`: keep only keys `K`.
-   `Record<K extends keyof any, V>`: map keys `K` to value type `V`.
-   `Partial<T>` / `Required<T>` / `Readonly<T>`: remap _all_ `keyof T`.
-   `Omit<T, K>`: remove a subset of keys.

Example:

```ts
type User = { id: string; name: string; email?: string };
type UserKeys = keyof User; // "id" | "name" | "email"
type PublicUser = Pick<User, "id" | "name">;
type Flags = Record<UserKeys, boolean>;
```

---

## 10) Key remapping & `as` in mapped types (advanced)

You can transform key _names_ using `as` + template literal types:

```ts
type PrefixKeys<T> = {
    [K in keyof T as `app_${Extract<K, string>}`]: T[K];
};

type Base = { id: number; ready: boolean };
type WithPrefix = PrefixKeys<Base>;
// { app_id: number; app_ready: boolean }
```

This pairs beautifully with `keyof` to reshape APIs.

---

## 11) Narrowing keys by value type

Filter keys whose values match a predicate type:

```ts
type KeysOfType<T, V> = {
    [K in keyof T]-?: T[K] extends V ? K : never;
}[keyof T];

type Example = { a: string; b: number; c?: string | null };
type StringKeys = KeysOfType<Example, string | null | undefined>; // "a" | "c"
```

Now `StringKeys` is a union of property names whose types are (assignable to) a target.

---

## 12) Common pitfalls & tips

-   **Union object access**: Even if `keyof (A | B)` is `"a" | "b"`, you can‚Äôt safely do `obj[key]` without narrowing which member you have.
-   **Arrays vs tuples**: `keyof string[]` is very wide (many methods). For fixed positions, prefer tuples so you get numeric literal keys (`"0" | "1" | ...`).
-   **Number vs string keys**: A `string` index signature implies `string | number` keys (due to coercion). If you _really_ need to block numeric-like keys, consider runtime validation.
-   **Symbols are first-class**: `keyof` preserves `symbol` keys; don‚Äôt forget them when working with meta-programming.
-   **`as const` is your friend**: Use it to preserve literal keys and values, then `keyof typeof` to get exact name unions.

---

## 13) Mini cheat sheet

```ts
type K1 = keyof { a: 1; b: 2 }; // "a" | "b"
type K2 = keyof { [n: number]: string }; // number
type K3 = keyof { [k: string]: boolean }; // string | number
type K4 = keyof any; // string | number | symbol
type K5 = keyof never; // never

type T = [string, number];
type KT = keyof T; // "0" | "1" | "length" | ...

const cfg = { host: "x", port: 5432 } as const;
type CfgKey = keyof typeof cfg; // "host" | "port"

type A = { a: string };
type B = { b: number };
type KU = keyof (A | B); // "a" | "b"
type KI = keyof (A & B); // "a" | "b"
```

---

---

# 2. The `typeof` Type Operator in TypeScript

## 1) Two different `typeof`s

-   **JavaScript `typeof` (runtime)**
    Evaluates an expression at runtime and returns a string describing the type.

    ```ts
    console.log(typeof "hello"); // "string"
    console.log(typeof 123); // "number"
    ```

-   **TypeScript `typeof` (compile time)**
    Used _in a type position_ to capture the **type of a value**.

    ```ts
    let s = "hello";
    let n: typeof s; // n has type string
    ```

---

## 2) Why it‚Äôs useful

For primitives, `typeof` isn‚Äôt very impressive‚Äî`typeof s` is just `string`.
But for **objects, functions, constants, and classes**, it‚Äôs essential:

```ts
const config = { host: "localhost", port: 8080 };
type Config = typeof config;
// { host: string; port: number }
```

This lets you avoid repeating types manually. ‚úÖ

---

## 3) Example: with utility types

`typeof` is often combined with built-in helpers like `ReturnType<T>`.

```ts
type Predicate = (x: unknown) => boolean;

type K = ReturnType<Predicate>; // boolean
```

If you pass a **function value** instead of its type, you‚Äôll see an error:

```ts
function f() {
    return { x: 10, y: 3 };
}

type Wrong = ReturnType<f>; // ‚ùå Error: f is a value
type Correct = ReturnType<typeof f>; // ‚úÖ { x: number; y: number }
```

üëâ Key point:
Values live in the _value space_, types live in the _type space_.
`typeof` is the bridge between the two.

---

## 4) `typeof` with constants & `as const`

Using `typeof` on a constant preserves literal types:

```ts
const COLORS = {
    red: "#ff0000",
    green: "#00ff00",
    blue: "#0000ff"
} as const;

type ColorName = keyof typeof COLORS; // "red" | "green" | "blue"
type ColorHex = (typeof COLORS)[ColorName]; // "#ff0000" | "#00ff00" | "#0000ff"
```

This pattern is common for enums or config maps.

---

## 5) `typeof` with functions

```ts
function add(a: number, b: number) {
    return a + b;
}

type AddFn = typeof add;
// (a: number, b: number) => number

type Result = ReturnType<typeof add>; // number
type Params = Parameters<typeof add>; // [a: number, b: number]
```

---

## 6) `typeof` with classes

Classes in TypeScript have two sides:

-   **Instance type** ‚Üí shape of objects created with `new`
-   **Constructor type** ‚Üí callable type of the class itself

```ts
class Person {
    name = "anonymous";
    constructor(public age: number) {}
}

// Instance type
type T1 = Person; // { name: string; age: number; }

// Constructor type
type T2 = typeof Person; // new (age: number) => Person
```

---

## 7) Limitations of `typeof` in types

TypeScript **restricts what you can apply `typeof` to in type positions**:

-   ‚úÖ Identifiers (variables, functions, classes)
-   ‚úÖ Properties of identifiers
-   ‚ùå Arbitrary expressions (e.g., `typeof (1 + 2)` in a type position)

Example of invalid usage:

```ts
// ‚ùå Error
let shouldContinue: typeof msgbox("Are you sure?");
```

Why?
Because that looks like you‚Äôre _calling a function_ in a type, which isn‚Äôt possible.
Instead, you must write:

```ts
let shouldContinue: ReturnType<typeof msgbox>;
```

---

## 8) Advanced patterns with `typeof`

### a) Safe access helpers

```ts
function get<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

const user = { id: 1, name: "Rohit" };
let x = get(user, "name"); // string
```

Here, `typeof user` could also be extracted as a type.

---

### b) Coupling runtime values to compile-time types

```ts
const routes = {
    home: "/",
    profile: "/user/:id"
} as const;

type RouteName = keyof typeof routes; // "home" | "profile"
function navigate(route: RouteName) {
    /* ... */
}

navigate("home"); // ‚úÖ
navigate("settings"); // ‚ùå Error
```

---

### c) Inferring API schemas

If you import a JSON file:

```ts
import pkg from "./package.json";
type PackageJson = typeof pkg;
```

You now have a type that mirrors the runtime structure.

---

## 9) Cheatsheet

```ts
// Primitives
let s = "hi";
type S = typeof s; // string

// Objects
const obj = { a: 1, b: "two" };
type Obj = typeof obj; // { a: number; b: string }

// Functions
function f(x: number) {
    return x.toString();
}
type F = typeof f; // (x: number) => string
type FR = ReturnType<typeof f>; // string
type FP = Parameters<typeof f>; // [x: number]

// Classes
class Car {
    drive() {}
}
type CarInstance = Car; // instance type
type CarClass = typeof Car; // constructor type

// Constants
const FLAGS = { on: true, off: false } as const;
type FlagKey = keyof typeof FLAGS; // "on" | "off"
type FlagVal = (typeof FLAGS)[FlagKey]; // true | false
```

---

---

# 3. Indexed Access Types in TypeScript

## 1) What they are

An **indexed access type** lets you _look up_ the type of a property by its key.

```ts
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"]; // number
```

It‚Äôs like accessing a property value at runtime (`person["age"]`), but at the **type level**.

---

## 2) Index can be:

-   A **string literal** (the property name)
-   A **union of keys**
-   `keyof` result
-   Another **type alias**

### Examples:

```ts
type I1 = Person["age" | "name"]; // number | string
type I2 = Person[keyof Person]; // number | string | boolean
type AliveOrName = "alive" | "name";
type I3 = Person[AliveOrName]; // boolean | string
```

---

## 3) Type errors for invalid keys

If you try to index with a property that doesn‚Äôt exist, TS will complain:

```ts
type Wrong = Person["alve"];
// ‚ùå Error: Property 'alve' does not exist on type 'Person'
```

This ensures **safe property lookups** at the type level.

---

## 4) Arrays & Tuples with indexed access

Arrays and tuples are objects with numeric keys, so you can use `number` (or specific numeric literals for tuples):

### Arrays

```ts
const numbers = [1, 2, 3];
type Element = (typeof numbers)[number]; // number
```

### Tuples

```ts
const pair = [10, "hello"] as const;
type First = (typeof pair)[0]; // 10
type Second = (typeof pair)[1]; // "hello"
```

---

## 5) Combining with `typeof`

Very powerful when working with constants:

```ts
const MyArray = [
    { name: "Alice", age: 15 },
    { name: "Bob", age: 23 },
    { name: "Eve", age: 38 }
];

type Person = (typeof MyArray)[number];
// { name: string; age: number }

type Age = (typeof MyArray)[number]["age"]; // number
// Or equivalently:
type Age2 = Person["age"]; // number
```

---

## 6) Keys must be _types_, not values

You **cannot** use a runtime variable directly as an index in a type:

```ts
const key = "age";
type Wrong = Person[key]; // ‚ùå Error: 'key' refers to a value, not a type
```

‚úÖ Instead, use a **type alias** or `typeof`:

```ts
type Key = "age";
type Age = Person[Key]; // number

const keyConst = "age" as const;
type Age2 = Person[typeof keyConst]; // number
```

---

## 7) Indexed access with unions & conditionals

When indexing with a union, you get a union of property types:

```ts
type Mixed = Person["name" | "alive"]; // string | boolean
```

This pairs well with conditional types to filter properties.

---

## 8) Practical use cases

### a) Extract element type from arrays

```ts
function first<T>(arr: T[]): T {
  return arr[0];
}

type Item = typeof ["a", "b", "c"][number]; // "a" | "b" | "c"
```

---

### b) Create reusable property extractors

```ts
type PropertyOf<T, K extends keyof T> = T[K];

type PersonName = PropertyOf<Person, "name">; // string
type PersonAll = PropertyOf<Person, keyof Person>; // number | string | boolean
```

---

### c) Combine with `keyof` and `typeof`

```ts
const STATUS = {
    draft: { editable: true },
    published: { editable: false }
} as const;

type Status = keyof typeof STATUS; // "draft" | "published"
type DraftStatus = (typeof STATUS)["draft"]; // { editable: true }
type Editable = (typeof STATUS)[Status]["editable"]; // true | false
```

---

## 9) Advanced patterns

### Extract only certain value types

```ts
type KeysOfType<T, V> = {
    [K in keyof T]: T[K] extends V ? K : never;
}[keyof T];

type Person = { name: string; age: number; alive: boolean };
type BoolKeys = KeysOfType<Person, boolean>; // "alive"
type BoolValues = Person[BoolKeys]; // boolean
```

---

## 10) Cheatsheet

```ts
type Obj = { a: string; b: number; c: boolean };

type A = Obj["a"]; // string
type B = Obj["a" | "b"]; // string | number
type C = Obj[keyof Obj]; // string | number | boolean

const arr = [1, 2, 3] as const;
type Elem = (typeof arr)[number]; // 1 | 2 | 3

const tuple = ["hi", 42] as const;
type First = (typeof tuple)[0]; // "hi"
type Second = (typeof tuple)[1]; // 42
```
