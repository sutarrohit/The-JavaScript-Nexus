# 1. Conditional Types in TypeScript

## 1) What they are

Conditional types allow types to behave like **if-else logic at the type level**.
They use the syntax:

```ts
SomeType extends OtherType ? TrueType : FalseType
```

-   If `SomeType` is assignable to `OtherType`, the result is `TrueType`.
-   Otherwise, the result is `FalseType`.

---

## 2) Basic Examples

```ts
interface Animal {
    live(): void;
}
interface Dog extends Animal {
    woof(): void;
}

type Example1 = Dog extends Animal ? number : string;
// number (true branch)

type Example2 = RegExp extends Animal ? number : string;
// string (false branch)
```

This is similar to runtime JS conditionals, but purely at the **type level**.

---

## 3) Why they’re useful

At first glance, it looks like we can always predict the result by hand.
The real power comes when **generics** are involved.

### Example: Overloads vs Conditional Types

Consider a function with multiple overloads:

```ts
interface IdLabel {
    id: number;
}
interface NameLabel {
    name: string;
}

function createLabel(id: number): IdLabel;
function createLabel(name: string): NameLabel;
function createLabel(nameOrId: string | number): IdLabel | NameLabel;
```

This works, but is verbose.

✅ Using a conditional type:

```ts
type NameOrId<T extends number | string> = T extends number ? IdLabel : NameLabel;

function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {
    throw "unimplemented";
}

let a = createLabel("ts"); // NameLabel
let b = createLabel(42); // IdLabel
let c = createLabel(Math.random() ? "hi" : 1);
// NameLabel | IdLabel
```

Much simpler — one generic replaces three overloads.

---

## 4) Conditional Type Constraints

Conditional types let you **narrow generics**.

Example:

```ts
type MessageOf<T> = T extends { message: unknown } ? T["message"] : never;

interface Email {
    message: string;
}
interface Dog {
    bark(): void;
}

type E = MessageOf<Email>; // string
type D = MessageOf<Dog>; // never
```

Here:

-   If `T` has a `message` property → extract it.
-   Otherwise → `never`.

---

## 5) Flattening Types

A common use case is to **unwrap types conditionally**:

```ts
type Flatten<T> = T extends any[] ? T[number] : T;

type S = Flatten<string[]>; // string
type N = Flatten<number>; // number
```

Here, arrays are flattened into their element type, while other types remain unchanged.

---

## 6) Inferring with `infer`

The `infer` keyword introduces a **new type variable** inside a conditional type.

### a) With arrays

```ts
type Flatten<T> = T extends Array<infer Item> ? Item : T;

type A = Flatten<string[]>; // string
type B = Flatten<number>; // number
```

`infer Item` means “pull out the array’s element type and call it `Item`”.

---

### b) With functions

```ts
type GetReturnType<T> = T extends (...args: never[]) => infer R ? R : never;

type Num = GetReturnType<() => number>; // number
type Str = GetReturnType<(x: string) => string>; // string
type Bools = GetReturnType<(a: boolean) => boolean[]>; // boolean[]
```

Here, we _infer_ the return type instead of manually extracting it.

⚠️ With overloaded functions, TypeScript infers from the **last overload** (the most general one).

```ts
declare function stringOrNum(x: string): number;
declare function stringOrNum(x: number): string;
declare function stringOrNum(x: string | number): string | number;

type T = ReturnType<typeof stringOrNum>;
// string | number
```

---

## 7) Distributive Conditional Types

When a conditional type is applied to a **union type**, it distributes across each member.

```ts
type ToArray<T> = T extends any ? T[] : never;

type R = ToArray<string | number>;
// (string[] | number[])
```

This works like mapping over each union member:

-   `ToArray<string>` → `string[]`
-   `ToArray<number>` → `number[]`

Final result: `string[] | number[]`.

---

### Preventing Distributivity

If you don’t want distribution, wrap the type in square brackets:

```ts
type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;

type R = ToArrayNonDist<string | number>;
// (string | number)[]
```

Now the union is kept whole.

---

## 8) Common Patterns

### a) Extracting property types safely

```ts
type PropType<T, K extends keyof T> = K extends keyof T ? T[K] : never;

type Person = { name: string; age: number };
type Age = PropType<Person, "age">; // number
type Invalid = PropType<Person, "x">; // never
```

---

### b) Nullable vs Non-nullable

```ts
type NonNull<T> = T extends null | undefined ? never : T;

type A = NonNull<string | null>; // string
```

---

### c) Promise unwrapping

```ts
type Awaited<T> = T extends Promise<infer U> ? U : T;

type A = Awaited<Promise<string>>; // string
type B = Awaited<number>; // number
```

---

## 9) Cheatsheet

```ts
// Basics
T extends U ? X : Y
// → if T is assignable to U, pick X, else Y

// Example
type IsString<T> = T extends string ? true : false;
type A = IsString<"hello">; // true
type B = IsString<42>;      // false

// Flatten array
type Flatten<T> = T extends Array<infer U> ? U : T;

// ReturnType extraction
type GetReturnType<T> =
  T extends (...args: any[]) => infer R ? R : never;

// Distributive
type Dist<T> = T extends any ? T[] : never;
type D = Dist<string | number>; // string[] | number[]

// Non-distributive
type NonDist<T> = [T] extends [any] ? T[] : never;
type ND = NonDist<string | number>; // (string | number)[]
```

---

---

# 2. Mapped Types in TypeScript

## 1) What they are

Mapped types let you **transform an existing type into a new type** by iterating over its keys.
They are built on **index signatures** + **`keyof`**.

### Example: index signature

```ts
type OnlyBoolsAndHorses = {
    [key: string]: boolean | Horse;
};

const conforms: OnlyBoolsAndHorses = {
    del: true,
    rodney: false
};
```

This says: for any `string` key, the value must be `boolean | Horse`.

---

## 2) Basic mapped type

The syntax is:

```ts
type NewType<OldType> = {
    [Key in keyof OldType]: NewValueType;
};
```

Example:

```ts
type OptionsFlags<Type> = {
    [Property in keyof Type]: boolean;
};

type Features = {
    darkMode: () => void;
    newUserProfile: () => void;
};

type FeatureOptions = OptionsFlags<Features>;
/* Result:
{
  darkMode: boolean;
  newUserProfile: boolean;
}
*/
```

---

## 3) Mapping modifiers

Mapped types can **add** or **remove** property modifiers:

-   `readonly`
-   `?` (optional)

Use `+` (add) or `-` (remove). Default = `+`.

### a) Remove `readonly`

```ts
type CreateMutable<Type> = {
    -readonly [Property in keyof Type]: Type[Property];
};

type LockedAccount = {
    readonly id: string;
    readonly name: string;
};

type UnlockedAccount = CreateMutable<LockedAccount>;
/* {
  id: string;
  name: string;
} */
```

### b) Remove `?`

```ts
type Concrete<Type> = {
    [Property in keyof Type]-?: Type[Property];
};

type MaybeUser = {
    id: string;
    name?: string;
    age?: number;
};

type User = Concrete<MaybeUser>;
/* {
  id: string;
  name: string;
  age: number;
} */
```

---

## 4) Key remapping (`as`)

Since TS 4.1, you can **rename keys** inside mapped types with `as`.

### a) Create getters

```ts
type Getters<Type> = {
    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property];
};

interface Person {
    name: string;
    age: number;
    location: string;
}

type LazyPerson = Getters<Person>;
/* {
  getName: () => string;
  getAge: () => number;
  getLocation: () => string;
} */
```

### b) Remove specific keys

```ts
type RemoveKindField<Type> = {
    [Property in keyof Type as Exclude<Property, "kind">]: Type[Property];
};

interface Circle {
    kind: "circle";
    radius: number;
}

type KindlessCircle = RemoveKindField<Circle>;
// { radius: number }
```

---

## 5) Mapped types over arbitrary unions

Not just `string | number | symbol` — you can map over **any union**.

```ts
type EventConfig<Events extends { kind: string }> = {
    [E in Events as E["kind"]]: (event: E) => void;
};

type SquareEvent = { kind: "square"; x: number; y: number };
type CircleEvent = { kind: "circle"; radius: number };

type Config = EventConfig<SquareEvent | CircleEvent>;
/* {
  square: (event: SquareEvent) => void;
  circle: (event: CircleEvent) => void;
} */
```

---

## 6) Advanced example with conditional types

Mapped types can include **conditional types** for per-property transformations.

```ts
type ExtractPII<Type> = {
    [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;
};

type DBFields = {
    id: { format: "incrementing" };
    name: { type: string; pii: true };
};

type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;
/* {
  id: false;
  name: true;
} */
```

---

## 7) Built-in utility types (all use mapped types!)

-   `Partial<T>` → makes all props optional
-   `Required<T>` → makes all props required
-   `Readonly<T>` → makes all props readonly
-   `Pick<T, K>` → select a subset of keys
-   `Record<K, V>` → build an object type with keys `K` and values `V`

Example:

```ts
type User = { id: number; name: string; email?: string };

type P = Partial<User>; // { id?: number; name?: string; email?: string }
type R = Required<User>; // { id: number; name: string; email: string }
type O = Readonly<User>; // { readonly id: number; ... }
type PK = Pick<User, "id" | "name">; // { id: number; name: string }
type Flags = Record<"a" | "b", boolean>; // { a: boolean; b: boolean }
```

---

## 8) Cheatsheet

```ts
// Basic map
type MapToBoolean<T> = { [K in keyof T]: boolean };

// Remove readonly
type Mutable<T> = { -readonly [K in keyof T]: T[K] };

// Remove optional
type Concrete<T> = { [K in keyof T]-?: T[K] };

// Key remap
type Prefixed<T> = {
    [K in keyof T as `app_${string & K}`]: T[K];
};

// Conditional per key
type FlagPII<T> = {
    [K in keyof T]: T[K] extends { pii: true } ? true : false;
};
```
