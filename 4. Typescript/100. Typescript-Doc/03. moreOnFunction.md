# **More on Functions in TypeScript**

Functions are one of the most fundamental building blocks of any application. In TypeScript, functions are treated as **first-class values**, meaning they can be stored in variables, passed as arguments, or returned from other functions. TypeScript provides various ways to **describe function types**, making them more precise and type-safe.

---

## **1. Function Type Expressions**

-   The simplest way to describe a function is with a **function type expression**.
-   Syntax looks similar to arrow functions:

```ts
function greeter(fn: (a: string) => void) {
    fn("Hello, World");
}

function printToConsole(s: string) {
    console.log(s);
}

greeter(printToConsole);
```

### Explanation:

-   `(a: string) => void` means:

    -   A function that takes **one parameter `a` of type string**.
    -   Returns **nothing** (`void`).

-   If a parameter type isn’t specified, it defaults to `any`.
-   Parameter **name is required**. Writing `(string) => void` would mean:

    -   Function has a parameter **named `string`** (not type `string`!) of type `any`.

✅ Correct: `(a: string) => void`
❌ Incorrect: `(string) => void`

### Using Type Aliases:

Instead of writing the function type repeatedly, we can define a **type alias**:

```ts
type GreetFunction = (a: string) => void;

function greeter(fn: GreetFunction) {
    fn("Hello");
}
```

---

---

## **2. Call Signatures**

-   In JavaScript, **functions can also have properties**, not just be callable.
-   A **function type expression** only describes callable behavior, not properties.
-   To describe a function with both callable behavior and properties, use a **call signature** inside an object type:

```ts
type DescribableFunction = {
    description: string;
    (someArg: number): boolean;
};

function doSomething(fn: DescribableFunction) {
    console.log(fn.description + " returned " + fn(6));
}

function myFunc(someArg: number) {
    return someArg > 3;
}
myFunc.description = "default description";

doSomething(myFunc);
```

### Key Points:

-   Syntax difference:

    -   Function type expression: `(a: string) => void`
    -   Call signature inside object: `(a: string): void`

-   Allows combining **properties + callable behavior**.

---

---

## **3. Construct Signatures**

-   In JavaScript, functions can also be used with the **`new` operator**.
-   TypeScript calls these **constructors** because they usually create a new object.
-   To describe such functions, use a **construct signature**:

```ts
type SomeConstructor = {
    new (s: string): SomeObject;
};

function fn(ctor: SomeConstructor) {
    return new ctor("hello");
}
```

### Key Points:

-   Syntax: `new (params): ReturnType`
-   Represents objects that can be created using `new`.

---

---

## **4. Call + Construct Signatures**

-   Some objects, like `Date`, can be called **with or without** `new`.
-   TypeScript allows combining **call signatures** and **construct signatures** in the same type:

```ts
interface CallOrConstruct {
    (n?: number): string; // callable
    new (s: string): Date; // constructible
}

function fn(ctor: CallOrConstruct) {
    console.log(ctor(10)); // matches callable signature
    console.log(new ctor("10")); // matches construct signature
}

fn(Date);
```

### Key Points:

-   `(n?: number): string` → describes when used as a **normal function**.
-   `new (s: string): Date` → describes when used with **`new`**.
-   Flexible typing for functions/objects usable both ways.

---

---

## 5. **Generic Functions in TypeScript**

Generics in TypeScript allow us to **write functions that are reusable, flexible, and type-safe**. Instead of using `any` (which loses type information), generics preserve the relationships between input and output types.

#### **1. Motivation: Why Generics?**

Consider a simple function that returns the first element of an array:

```ts
function firstElement(arr: any[]) {
    return arr[0];
}
```

-   ✅ Works at runtime, but **return type is `any`**.
-   ❌ Loses type information of the array.

What we want: **return type should match array element type**.

---

#### **2. Introducing Generics**

Generics describe a **correspondence** between values and types using **type parameters**.

```ts
function firstElement<Type>(arr: Type[]): Type | undefined {
    return arr[0];
}
```

#### Example Usage:

```ts
const s = firstElement(["a", "b", "c"]); // s: string
const n = firstElement([1, 2, 3]); // n: number
const u = firstElement([]); // u: undefined
```

-   A type parameter `Type` is introduced.
-   TypeScript **infers** the type argument (`string`, `number`, etc.) automatically.

---

#### **3. Type Inference in Generics**

-   Type arguments are usually **inferred** automatically.
-   Example with multiple type parameters:

```ts
function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
    return arr.map(func);
}

const parsed = map(["1", "2", "3"], (n) => parseInt(n));
// parsed: number[]
```

-   `Input` inferred as `string`.
-   `Output` inferred as `number`.

---

#### **4. Constraints in Generics**

Sometimes we want to restrict the allowed types for a generic parameter.
We use **`extends`** to apply constraints.

```ts
function longest<Type extends { length: number }>(a: Type, b: Type) {
    return a.length >= b.length ? a : b;
}
```

#### Example:

```ts
const longerArray = longest([1, 2], [1, 2, 3]); // number[]
const longerString = longest("alice", "bob"); // "alice" | "bob"
const notOK = longest(10, 100); // ❌ Error: number lacks .length
```

-   Constraint ensures only values with a `.length` property are valid.
-   TypeScript infers return type based on inputs.

---

#### **5. Working with Constrained Values**

A common mistake:

```ts
function minimumLength<Type extends { length: number }>(obj: Type, minimum: number): Type {
    if (obj.length >= minimum) {
        return obj;
    } else {
        return { length: minimum }; // ❌ Error
    }
}
```

Why error?

-   Function promises to return the **same type** as input (`Type`).
-   `{ length: number }` matches the constraint but isn’t necessarily the same as the input type.

Example crash:

```ts
const arr = minimumLength([1, 2, 3], 6);
// arr expected as array, but returned object lacks .slice
console.log(arr.slice(0)); // runtime error!
```

---

#### **6. Specifying Type Arguments**

TypeScript usually infers generics, but you can specify them manually:

```ts
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
    return arr1.concat(arr2);
}

const arr = combine([1, 2, 3], ["hello"]); // ❌ Error
```

Fix with explicit union type:

```ts
const arr = combine<string | number>([1, 2, 3], ["hello"]);
// arr: (string | number)[]
```

---

#### **7. Guidelines for Writing Good Generic Functions**

#### (a) Push Type Parameters Down

Avoid unnecessary constraints that weaken type inference.

```ts
function firstElement1<Type>(arr: Type[]) {
    return arr[0];
}

function firstElement2<Type extends any[]>(arr: Type) {
    return arr[0];
}

const a = firstElement1([1, 2, 3]); // a: number ✅
const b = firstElement2([1, 2, 3]); // b: any ❌
```

**Rule:** Prefer using the type parameter directly instead of constraining it unnecessarily.

---

#### (b) Use Fewer Type Parameters

Extra unused type parameters make code harder to read.

```ts
// Better
function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
    return arr.filter(func);
}

// Worse (extra generic Func adds no value)
function filter2<Type, Func extends (arg: Type) => boolean>(arr: Type[], func: Func): Type[] {
    return arr.filter(func);
}
```

**Rule:** Only introduce type parameters when needed.

#### (c) Type Parameters Should Appear Twice

A generic should relate multiple values. If a type parameter is only used once, you probably don’t need it.

```ts
// Unnecessary generic
function greet<Str extends string>(s: Str) {
    console.log("Hello, " + s);
}

// Better
function greet(s: string) {
    console.log("Hello, " + s);
}
```

**Rule:** If a type parameter only appears in one location, reconsider if it’s needed.

---

---

## 6. Optional Parameters

-   In JavaScript, functions can be called with fewer arguments than declared parameters → missing arguments become `undefined`.
-   **TypeScript syntax**:

    ```ts
    function f(x?: number) {}
    ```

    -   `x` is now of type `number | undefined`.
    -   Calls:

        ```ts
        f(); // OK → x is undefined
        f(10); // OK
        ```

#### Default Parameters

-   Provide a default value:

    ```ts
    function f(x = 10) {}
    ```

-   If caller passes `undefined`, it’s replaced with the default:

    ```ts
    f(); // x = 10
    f(5); // x = 5
    f(undefined); // x = 10
    ```

### Optional Parameters in Callbacks

-   Common mistake: writing an optional parameter in a callback when the function **always passes that argument**.
-   Example:

    ```ts
    function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
        for (let i = 0; i < arr.length; i++) {
            callback(arr[i], i); // index always passed
        }
    }
    ```

-   Intended usage:

    ```ts
    myForEach([1, 2, 3], (a) => console.log(a)); // OK
    myForEach([1, 2, 3], (a, i) => console.log(a, i)); // OK
    ```

-   Problem: marking `index?` means callback _might_ be called without it, so inside callback:

    ```ts
    (a, i) => {
        console.log(i.toFixed()); // Error: 'i' possibly undefined
    };
    ```

✅ **Rule:** Never mark a callback parameter optional unless you actually plan to omit it when calling.

---

---

## 7. Function Overloads

-   JavaScript functions often allow multiple ways to call them.
-   **Overloading in TS**:

    ```ts
    function makeDate(timestamp: number): Date;
    function makeDate(m: number, d: number, y: number): Date;
    function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
        if (d !== undefined && y !== undefined) {
            return new Date(y, mOrTimestamp, d);
        }
        return new Date(mOrTimestamp);
    }
    ```

### Key Rules:

1. **Overload Signatures** – user-facing (e.g. `makeDate(timestamp: number)`).

2. **Implementation Signature** – actual body; not directly callable.

    - Example mistake:

        ```ts
        function fn(x: string): void;
        function fn() {} // Implementation has no parameters
        fn(); // ❌ Error: Expected 1 argument
        ```

3. Overload signatures must be **compatible** with the implementation.

### Good Overloads

-   Example:

    ```ts
    function len(s: string): number;
    function len(arr: any[]): number;
    function len(x: any) {
        return x.length;
    }
    ```

-   Problem: cannot call with a union type (`string | any[]`).
-   ✅ Prefer **union types** over overloads:

    ```ts
    function len(x: string | any[]) {
        return x.length;
    }
    ```

---

---

## 8. Declaring `this` in Functions

-   JS `this` is inferred from context.
-   TypeScript allows explicit `this` parameter in function signatures:

    ```ts
    interface DB {
        filterUsers(filter: (this: User) => boolean): User[];
    }

    db.filterUsers(function (this: User) {
        return this.admin;
    });
    ```

-   ❌ Arrow functions don’t have their own `this` (capture outer `this`):

    ```ts
    db.filterUsers(() => this.admin); // Error
    ```

### Other Function-Related Types

### `void`

-   For functions that don’t return a value.

    ```ts
    function log(): void {
        console.log("Hi");
    }
    ```

-   Difference: `void` ≠ `undefined`.

### `object`

-   Represents any **non-primitive** (arrays, objects, functions).
-   Use `object` instead of `Object` (capitalized one is less useful).

### `unknown`

-   Safer alternative to `any`.
-   Cannot use properties/methods without type-checking first.

    ```ts
    function safeParse(s: string): unknown {
        return JSON.parse(s);
    }
    ```

### `never`

-   Represents values that never occur.
-   Used for:

    -   Functions that throw:

        ```ts
        function fail(msg: string): never {
            throw new Error(msg);
        }
        ```

    -   Exhaustive checks in unions:

        ```ts
        function fn(x: string | number) {
          if (typeof x === "string") {}
          else if (typeof x === "number") {}
          else { x; // type 'never' }
        }
        ```

### `Function`

-   Very general type: allows any callable.
-   Avoid using it (unsafe, returns `any`).
-   Prefer `() => void` or specific signatures.

---

---

## 9. Rest Parameters and Arguments

### Rest Parameters

-   Collect multiple arguments into an array:

    ```ts
    function multiply(n: number, ...m: number[]) {
        return m.map((x) => n * x);
    }
    multiply(10, 1, 2, 3, 4); // [10,20,30,40]
    ```

### Rest Arguments

-   Spread an iterable as arguments:

    ```ts
    const arr1 = [1, 2, 3];
    const arr2 = [4, 5, 6];
    arr1.push(...arr2);
    ```

-   To preserve tuple types:

    ```ts
    const args = [8, 5] as const;
    Math.atan2(...args); // OK
    ```

### Parameter Destructuring

-   Directly destructure object parameters:

    ```ts
    function sum({ a, b, c }: { a: number; b: number; c: number }) {
        return a + b + c;
    }
    sum({ a: 1, b: 2, c: 3 });
    ```

-   With a type alias:

    ```ts
    type ABC = { a: number; b: number; c: number };
    function sum({ a, b, c }: ABC) {
        return a + b + c;
    }
    ```

---

## 10. Assignability of Functions

#### Return Type `void`

-   A `void` function can still return a value, but it will be ignored:

    ```ts
    type voidFunc = () => void;
    const f1: voidFunc = () => true; // Allowed
    const v1 = f1(); // v1: void
    ```

-   Useful for cases like:

    ```ts
    src.forEach((el) => dst.push(el));
    // push returns number, but forEach expects void return type – works fine
    ```

-   Exception: if function is explicitly declared with `(): void`, returning a value is not allowed:

    ```ts
    function f2(): void {
        return true;
    } // ❌ Error
    ```

---

## Summary Rules

1. Use `?` for optional parameters → `number | undefined`.
2. Provide defaults when useful → ensures parameter has non-undefined type.
3. Don’t misuse optional parameters in callbacks – only use if you may omit it.
4. Prefer union types over overloads when possible.
5. Always declare `this` in callbacks when needed.
6. Use `unknown` instead of `any` for safety.
7. Use `never` for impossible states.
8. Use rest (`...args`) for variable arguments and spread (`...arr`) for expanding arrays.
9. Prefer destructuring with type aliases for clean code.
10. Avoid the general `Function` type; use specific signatures.
