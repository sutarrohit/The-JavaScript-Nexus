# Everyday Types

This chapter introduces the **most common types in TypeScript**, their usage, and how they map to JavaScript values. These types form the **building blocks** for writing safer, more expressive code.

## 1. **Primitive Types**

JavaScript has three commonly used primitive values, each with a direct TypeScript equivalent:

-   **string** ‚Üí represents text values.
    Example: `"Hello, world"`
    ‚úÖ Use `string` (lowercase), not `String`.

-   **number** ‚Üí represents all numbers (integers, floats, etc.).
    Example: `42`
    ‚ö° JavaScript does not distinguish between `int` and `float`.

-   **boolean** ‚Üí represents `true` or `false`.

‚ö†Ô∏è Important: `String`, `Number`, and `Boolean` (capitalized) refer to wrapper objects and are almost never needed. Always prefer lowercase versions.

---

## 2. **Arrays**

Two ways to define arrays:

-   **Shorthand syntax** ‚Üí `number[]`, `string[]`, etc.
-   **Generic syntax** ‚Üí `Array<number>`, `Array<string>`, etc.

Example:

```ts
let nums: number[] = [1, 2, 3];
let strs: Array<string> = ["a", "b"];
```

‚ö†Ô∏è `number[]` ‚â† `[number]`. The latter is a **tuple**.

---

## 3. **The `any` Type**

-   Special type that disables type checking.
-   Lets you perform any operation (property access, function calls, assignments).
    Example:

    ```ts
    let obj: any = { x: 0 };
    obj.foo();
    obj = "hello";
    const n: number = obj; // OK
    ```

üëâ Use `any` sparingly. It bypasses safety.

---

## 4. **`noImplicitAny` Compiler Option**

-   If TypeScript cannot infer a type and you don‚Äôt provide one, it defaults to `any`.
-   Enable `noImplicitAny` to **disallow accidental `any` types**.

---

## 5. **Type Annotations on Variables**

-   Syntax: `let varName: type = value;`
-   Example:

    ```ts
    let myName: string = "Alice";
    ```

-   TypeScript usually infers types, so annotations are often unnecessary:

    ```ts
    let myName = "Alice"; // inferred as string
    ```

---

## 6. **Functions**

Functions define **input (parameters)** and **output (return values)**.

### a. Parameter Annotations

```ts
function greet(name: string) {
    console.log("Hello " + name.toUpperCase());
}
```

### b. Return Type Annotations

```ts
function getFavoriteNumber(): number {
    return 26;
}
```

Often unnecessary‚ÄîTypeScript can infer return types.

### c. Async Functions with Promises

```ts
async function fetchNumber(): Promise<number> {
    return 42;
}
```

### d. Anonymous Functions & Contextual Typing

-   TypeScript infers types based on context:

```ts
const names = ["Alice", "Bob"];
names.forEach((s) => console.log(s.toUpperCase()));
```

---

## 7. **Object Types**

Objects are described by their **properties and types**.

```ts
function printCoord(pt: { x: number; y: number }) {
    console.log(pt.x, pt.y);
}
```

### a. Optional Properties

Add `?` for optional fields:

```ts
function printName(obj: { first: string; last?: string }) {
    console.log(obj.first, obj.last?.toUpperCase());
}
```

---

## 8. **Union Types**

Allow values to be **one of several types**:

```ts
function printId(id: number | string) {
    console.log("ID:", id);
}
```

### Narrowing with type guards:

```ts
if (typeof id === "string") {
    console.log(id.toUpperCase()); // string branch
} else {
    console.log(id); // number branch
}
```

Other examples: `Array.isArray(x)` for array vs. string.

üëâ Only properties/methods common to all union members are directly usable.

---

## 9. **Type Aliases**

-   Define reusable names for types:

```ts
type Point = { x: number; y: number };
type ID = string | number;
```

-   Aliases don‚Äôt create distinct types; they‚Äôre just names.

---

## 10. **Interfaces**

-   Another way to name object shapes:

```ts
interface Point {
    x: number;
    y: number;
}
```

-   TypeScript uses **structural typing**: only checks that objects have the right properties.

---

## 11. **Type Alias vs Interface**

-   **Interfaces**:

    -   Can be extended (`extends`)
    -   Can be merged (declaration merging)

-   **Type Aliases**:

    -   Cannot be re-opened once defined
    -   Can represent unions and primitives

üëâ Rule of thumb: use `interface` unless you need features of `type`.

---

## 12. **Type Assertions**

Tell TypeScript to treat a value as a more specific type:

```ts
const myCanvas = document.getElementById("main") as HTMLCanvasElement;
```

Alternative syntax:

```ts
const myCanvas = <HTMLCanvasElement>document.getElementById("main");
```

‚ö†Ô∏è No runtime check‚Äîonly affects compile-time. Use carefully.

---

## 13. **Literal Types**

-   Variables can be restricted to specific values:

```ts
let x: "hello" = "hello";
```

-   Combine with unions for useful constraints:

```ts
function printText(s: string, align: "left" | "right" | "center") {}
```

-   Works with numbers, strings, and booleans (`true | false`).

---

## 14. **Literal Inference**

-   TypeScript widens types by default:

```ts
const req = { method: "GET" }; // method inferred as string
```

Fix with:

-   `as const`
-   or `as "GET"`

---

## 15. **null and undefined**

-   Two primitives for absence.
-   Behavior depends on `strictNullChecks`.

### a. With `strictNullChecks: off`

-   `null`/`undefined` assignable to any type.
-   Unsafe, bug-prone.

### b. With `strictNullChecks: on`

-   Must explicitly handle `null` and `undefined`.
-   Example:

```ts
function doSomething(x: string | null) {
    if (x !== null) console.log(x.toUpperCase());
}
```

---

## 16. **Non-null Assertion (`!`)**

Remove `null` and `undefined` from a type:

```ts
function liveDangerously(x?: number | null) {
    console.log(x!.toFixed());
}
```

‚ö†Ô∏è Dangerous if value really is `null`.

---

## 17. **Enums**

-   TypeScript feature to define **named constants**.
-   Adds runtime code (not purely type-level).
    üëâ Often replaced by union literal types.

---

## 18. **Less Common Primitives**

-   **bigint** ‚Üí for very large integers:

    ```ts
    const big: bigint = 100n;
    ```

-   **symbol** ‚Üí unique identifiers:

    ```ts
    const sym = Symbol("id");
    ```

---

# ‚úÖ Key Takeaways

1. Start with basic primitives (`string`, `number`, `boolean`).
2. Use arrays, unions, and objects to model data.
3. `any` bypasses safety ‚Üí avoid unless absolutely needed.
4. Use **interfaces** for objects, **types** for unions/primitives.
5. Use **literal types** to constrain valid values.
6. Enable `strictNullChecks` for safety.
7. Assertions (`as`, `!`) provide escape hatches‚Äîbut use cautiously.
