## ⚠️ Mutability Warning

All five methods (`push`, `pop`, `shift`, `unshift`,`splice`) **mutate** the original array:

---

## 1. `push()` — Add to the End

**Purpose:**
Adds one or more elements to the **end** of an array.

**Syntax:**

```js
array.push(element1, element2, ..., elementN)
```

**Example:**

```js
let arr = [1, 2, 3];
let result = arr.push(4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
console.log(result); // 5 (new length)
```

**Key Points:**

-   Mutates the original array.
-   Returns the **new length** of the array.
-   You can push multiple elements at once.

---

## 2. `pop()` — Remove from the End

**Purpose:**
Removes the **last element** from an array.

**Syntax:**

```js
array.pop();
```

**Example:**

```js
let arr = [1, 2, 3];
let result = arr.pop();
console.log(arr); // [1, 2]
console.log(result); // 3 (the removed element)
```

**Key Points:**

-   Removes only **one element** at a time.
-   Returns the **removed element**.
-   Mutates the original array.
-   If the array is empty, it returns `undefined`.

---

## 3. `unshift()` — Add to the Start

**Purpose:**
Adds one or more elements to the **beginning** of an array.

**Syntax:**

```js
array.unshift(element1, element2, ..., elementN)
```

**Example:**

```js
let arr = [3, 4, 5];
let result = arr.unshift(1, 2);
console.log(arr); // [1, 2, 3, 4, 5]
console.log(result); // 5 (new length)
```

**Key Points:**

-   Mutates the original array.
-   Shifts existing elements to the right.
-   Returns the **new array length**.
-   Slower than `push()` because all indexes must be reindexed.

---

## 4. `shift()` — Remove from the Start

**Purpose:**
Removes the **first element** from an array.

**Syntax:**

```js
array.shift();
```

**Example:**

```js
let arr = [1, 2, 3];
let result = arr.shift();
console.log(arr); // [2, 3]
console.log(result); // 1 (the removed element)
```

**Key Points:**

-   Removes only **one element** at a time.
-   Returns the **removed element**.
-   Mutates the original array.
-   Shifts all other elements one position down.

---

## 5. `splice()` — add / remove / replace by index (deep dive)

`Array.prototype.splice()` is a powerful, **mutating** array method that can **remove**, **insert**, or **replace** elements at any index. Because it changes the original array, use it carefully when you need immutability (for example, in React state).

### Signature & basic behavior

```js
arr.splice(start[, deleteCount[, item1[, item2[, ...]]]])
```

-   **`start`** — index at which to start changing the array.

    -   Will be converted to an integer.
    -   If negative, it’s treated as `arr.length + start`. If still negative, treated as `0`.
    -   If `start` > `arr.length`, it will be clamped to `arr.length` (inserts at end).

-   **`deleteCount`** (optional) — number of elements to remove from `start`.

    -   If omitted, all elements from `start` to the end are removed.
    -   If `deleteCount` is greater than available elements, it removes up to the end.
    -   If `deleteCount` is `0`, it performs only insertion (no removals).

-   **`item1, item2, ...`** — elements to insert at `start` (can be zero or many).

**Returns:** a new array containing the **removed elements** (or `[]` if nothing was removed).

**Mutates:** the original array—its contents and `length` change.

### Examples

#### 1) Remove elements

```js
let a = [10, 20, 30, 40, 50];
let removed = a.splice(2, 2); // start=2, delete 2 elements
// a => [10, 20, 50]
// removed => [30, 40]
```

#### 2) Insert elements (no removal)

```js
let a = [1, 2, 5];
a.splice(2, 0, 3, 4); // at index 2 insert 3 and 4
// a => [1,2,3,4,5]
```

#### 3) Replace elements (remove + insert)

```js
let a = ["a", "b", "c", "d"];
a.splice(1, 2, "x", "y");
// a => ['a','x','y','d']
// removed => ['b','c']
```

#### 4) Remove everything from index

```js
let a = [1, 2, 3, 4];
let removed = a.splice(1); // deleteCount omitted => remove to end
// a => [1]
// removed => [2,3,4]
```

#### 5) Negative start index

```js
let a = [1, 2, 3, 4, 5];
a.splice(-2, 1); // start = length - 2 => index 3, remove one (the 4)
// a => [1,2,3,5]
```

#### 6) Start beyond length -> insert at end

```js
let a = [1, 2];
a.splice(10, 0, 3); // start clamped to length (2)
// a => [1,2,3]
```

### Edge cases & spec details (practical)

-   `start` and `deleteCount` are converted to integers (floored toward zero). Non-integer values are truncated.
-   If `deleteCount` is omitted, all elements from `start` to the end are removed.
-   If `deleteCount` ≤ 0 (or `0`), no elements are removed (but you can still insert).
-   The method returns an **array** (possibly empty) of removed items.
-   Works on sparse arrays — holes are treated like `undefined` entries for removal/insertion effects.

### Performance

-   `splice()` is O(n) in the worst case because elements after `start` may need to be shifted to fill gaps or make room.
-   Removing/inserting at the **start** (`shift`/`unshift` equivalent via `splice`) is generally slower than operating at the end (`push`/`pop`) for large arrays.

### Common patterns

#### Remove by value (first occurrence)

```js
const arr = [1, 2, 3, 2, 4];
const idx = arr.indexOf(2);
if (idx !== -1) arr.splice(idx, 1); // removes first 2
```

#### Replace a single element at index

```js
arr.splice(i, 1, newValue); // removes 1 element at i and inserts newValue
```

#### Insert without removing

```js
arr.splice(i, 0, x); // insert x at i
```

#### Empty the array (mutating)

```js
arr.splice(0); // removes everything, arr becomes []
```

#### Remove while iterating — avoid skipping items

If you loop forward and remove items, indices shift and you can skip elements. Two solutions:

-   iterate **backwards**:

```js
for (let i = arr.length - 1; i >= 0; i--) {
    if (shouldRemove(arr[i])) arr.splice(i, 1);
}
```

-   or collect indices to remove and then remove in reverse order.

### Immutable alternatives (do not mutate original)

If you need to preserve the original array (e.g., React state), use slice/spread/concat to build a new array.

-   **Remove at index i**:

```js
const newArr = [...arr.slice(0, i), ...arr.slice(i + 1)];
```

-   **Insert at index i**:

```js
const newArr = [...arr.slice(0, i), ...itemsToInsert, ...arr.slice(i)];
```

-   **Replace at index i**:

```js
const newArr = [...arr.slice(0, i), newVal, ...arr.slice(i + 1)];
```

These are O(n) as well, but they return a new array instead of mutating the old one.

### Practical tips / gotchas

-   Because `splice()` mutates, avoid using it on arrays where references are shared or immutability is required.
-   `splice()` can be used to implement `shift`, `unshift`, `push`, and `pop` behaviors, but using the dedicated methods (`push/pop/shift/unshift`) is clearer.
-   When removing many items, remove from the end backwards to minimize shifts if you can.
-   Use the returned array from `splice()` when you need the removed items.
