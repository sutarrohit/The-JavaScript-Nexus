# 1. Object Prototype

- In JavaScript, the **prototype** is an object that is associated with every function and object. It allows objects to inherit properties and methods from other objects. This is a key feature of JavaScript's prototype-based inheritance model.

- Every object in JavaScript has a built-in property, which is called its prototype. The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.

---

### **Key Concepts of Object Prototype**

1. **Prototype Property (`__proto__`)**:

   - Every JavaScript object has an internal property called `[[Prototype]]` (commonly accessed via `__proto__`) that points to its prototype.
   - The prototype is another object from which the current object can inherit methods and properties.

2. **Prototype Chain**:

   - If a property or method is not found in the current object, JavaScript looks up the prototype chain to find it.
   - The chain ends when it reaches `null`, which is the prototype of the base `Object`.

3. **Prototype Object**:
   - Functions in JavaScript have a `prototype` property, which is an object used as a blueprint for creating new objects.

---

### **Example of Prototype Inheritance**

#### Example 1: Simple Prototype Chain

```javascript
const parent = {
  greet: function () {
    console.log("Hello from parent!");
  },
};

const child = Object.create(parent); // child inherits from parent
child.greet(); // "Hello from parent!"
```

#### Example 2: Adding Methods to Prototype

```javascript
function Person(name) {
  this.name = name;
}

// Adding a method to Person's prototype
Person.prototype.sayHello = function () {
  console.log(`Hello, my name is ${this.name}.`);
};

const person1 = new Person("Alice");
person1.sayHello(); // "Hello, my name is Alice."
```

---

### **Prototype Chain in Action**

1. **Direct Property Lookup**:

   - JavaScript first checks the object itself for a property.

2. **Prototype Lookup**:

   - If the property is not found, JavaScript searches the object's prototype chain.

3. **End of Chain**:
   - If no property is found in the chain, `undefined` is returned.

#### Example:

```javascript
const grandparent = { role: "grandparent" };
const parent = Object.create(grandparent);
const child = Object.create(parent);

console.log(child.role); // "grandparent" (found in grandparent)
```

---

### **Key Properties and Methods**

1. **`Object.getPrototypeOf(obj)`**:

   - Returns the prototype of the given object.

   ```javascript
   const obj = {};
   console.log(Object.getPrototypeOf(obj)); // {}
   ```

2. **`Object.setPrototypeOf(obj, prototype)`**:

   - Sets the prototype of the given object.

   ```javascript
   const obj = {};
   const prototype = { greet: () => console.log("Hello!") };
   Object.setPrototypeOf(obj, prototype);
   obj.greet(); // "Hello!"
   ```

3. **`__proto__`** (Deprecated but still widely used):
   - Accesses an object’s prototype directly.
   ```javascript
   const obj = {};
   console.log(obj.__proto__ === Object.prototype); // true
   ```

---

### **Prototype and Constructor Functions**

When a new object is created using a constructor function, it inherits from the constructor’s `prototype` object.

#### Example:

```javascript
function Car(model) {
  this.model = model;
}

Car.prototype.drive = function () {
  console.log(`${this.model} is driving.`);
};

const myCar = new Car("Tesla");
myCar.drive(); // "Tesla is driving."
```

---

### **Prototype Chain Visualization**

Consider this chain:

```javascript
const obj = {};
```

- `obj.__proto__` points to `Object.prototype`.
- `Object.prototype.__proto__` points to `null`.

Chain:

```
obj → Object.prototype → null
```

---

### **Customizing Prototypes**

You can create your own prototypes for shared behavior across objects:

```javascript
const animal = {
  eat: function () {
    console.log("Eating...");
  },
};

const dog = Object.create(animal);
dog.bark = function () {
  console.log("Barking...");
};

dog.eat(); // "Eating..." (inherited from animal)
dog.bark(); // "Barking..."
```

---

### **Best Practices**

1. **Avoid Modifying Built-in Prototypes**:

   - Modifying prototypes of built-in objects like `Array` or `Object` can lead to conflicts.

   ```javascript
   Array.prototype.customMethod = function () {
     console.log("Custom method");
   };
   ```

2. **Use Object.create() for Prototyping**:

   - Use `Object.create(prototype)` to create objects with a specific prototype.

   ```javascript
   const base = { greet: () => console.log("Hello!") };
   const obj = Object.create(base);
   obj.greet(); // "Hello!"
   ```

3. **Use Classes for Modern Syntax**:
   - In modern JavaScript, use `class` syntax to work with prototypes in a cleaner way.

---

### **Modern JavaScript: Classes and Prototypes**

The `class` syntax in JavaScript is syntactic sugar for working with prototypes.

#### Example:

```javascript
class Animal {
  eat() {
    console.log("Eating...");
  }
}

class Dog extends Animal {
  bark() {
    console.log("Barking...");
  }
}

const myDog = new Dog();
myDog.eat(); // "Eating..."
myDog.bark(); // "Barking..."
```

Under the hood, `class` syntax uses prototypes for inheritance.

---

### **Summary**

- Prototypes enable inheritance in JavaScript.
- Objects inherit from other objects via the prototype chain.
- Functions have a `prototype` property used for inheritance.
- Use modern `class` syntax for a cleaner approach to prototype-based inheritance.

---

# **2. Prototype Inheritance**

### **What is Prototype Inheritance?**

* **Prototype Inheritance** (also called *prototypal inheritance*) is a mechanism in JavaScript that allows objects to inherit properties and methods from other objects.
* Instead of copying properties (like in class-based inheritance), JavaScript objects *link* to a prototype object and **delegate** property access to it.
* This linkage forms the **prototype chain**, allowing code reusability and efficient memory usage.

---

### **How It Works**

When you try to access a property or method on an object:

1. JavaScript first checks if the property exists on the object itself.
2. If not found, it looks at the object's prototype (`__proto__` or `[[Prototype]]`).
3. This continues up the **prototype chain** until:

   * The property is found, or
   * The end of the chain (`null`) is reached — in which case, `undefined` is returned.

---

### **Example 1: Basic Prototype Inheritance**

```javascript
const animal = {
  eats: true,
  walk() {
    console.log("Animal is walking");
  },
};

// dog inherits from animal
const dog = Object.create(animal);
dog.barks = true;

console.log(dog.eats); // true (inherited from animal)
dog.walk(); // "Animal is walking"
```

**Explanation:**

* `dog` does not have the property `eats` or method `walk`.
* JavaScript automatically looks into `dog`’s prototype (`animal`) to find them.

---

### **Example 2: Multi-level Prototype Chain**

```javascript
const livingBeing = { alive: true };
const animal = Object.create(livingBeing);
animal.eats = true;

const dog = Object.create(animal);
dog.barks = true;

console.log(dog.alive); // true (from livingBeing)
console.log(dog.eats);  // true (from animal)
console.log(dog.barks); // true (own property)
```

**Prototype Chain:**

```
dog → animal → livingBeing → Object.prototype → null
```

---

### **Example 3: Constructor Function Inheritance**

Before ES6 `class`, constructor functions were used for inheritance via prototypes.

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function () {
  console.log(`${this.name} is eating.`);
};

function Dog(name, breed) {
  Animal.call(this, name); // call parent constructor
  this.breed = breed;
}

// Inherit from Animal.prototype
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function () {
  console.log(`${this.name} is barking.`);
};

const myDog = new Dog("Buddy", "Golden Retriever");
myDog.eat();  // "Buddy is eating."
myDog.bark(); // "Buddy is barking."
```

**Key Steps:**

1. Call the parent constructor with `Animal.call(this, name)` to inherit instance properties.
2. Set `Dog.prototype = Object.create(Animal.prototype)` to inherit prototype methods.
3. Reset `Dog.prototype.constructor = Dog` to maintain proper constructor reference.

---

### **Example 4: Using `class` Syntax (Modern Approach)**

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    console.log(`${this.name} is eating.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // calls parent constructor
    this.breed = breed;
  }

  bark() {
    console.log(`${this.name} is barking.`);
  }
}

const myDog = new Dog("Charlie", "Beagle");
myDog.eat();  // "Charlie is eating."
myDog.bark(); // "Charlie is barking."
```

**Under the Hood:**
The `class` syntax still uses **prototypal inheritance**, but with a cleaner, more readable syntax.

---

### **Example 5: Checking Prototype Relationships**

```javascript
console.log(Dog.prototype instanceof Animal); // false
console.log(Dog.prototype.__proto__ === Animal.prototype); // true
console.log(myDog instanceof Dog); // true
console.log(myDog instanceof Animal); // true
console.log(myDog instanceof Object); // true
```

**Explanation:**

* `Dog.prototype.__proto__` points to `Animal.prototype`.
* This forms the inheritance chain between the classes.

---

### **Example 6: Extending Built-in Objects**

You can also extend built-in prototypes like `Array` or `Date`, though it’s not always recommended.

```javascript
class CustomArray extends Array {
  first() {
    return this[0];
  }
}

const arr = new CustomArray(1, 2, 3);
console.log(arr.first()); // 1
```

---

### **Prototype Inheritance Chain Summary**

For an object `myDog` created from `Dog` class:

```
myDog → Dog.prototype → Animal.prototype → Object.prototype → null
```

Each link in the chain provides properties and methods to the object below it.

---

### **Best Practices**

✅ **Prefer `class` syntax** for clarity and readability.
✅ **Use `Object.create()`** when manually setting up prototype chains.
✅ **Do not modify built-in prototypes** (e.g., `Array.prototype`, `Object.prototype`).
✅ **Use `Object.getPrototypeOf()` and `Object.setPrototypeOf()`** for safe prototype manipulation.

---

### **Summary**

* Prototype inheritance allows objects to share behavior efficiently.
* The chain continues until `null` (end of inheritance).
* ES6 `class` syntax simplifies working with prototypes.
* Always favor clarity over manually manipulating prototypes.
